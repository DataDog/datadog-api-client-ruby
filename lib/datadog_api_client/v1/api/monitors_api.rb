=begin
#Datadog API V1 Collection

#Collection of all Datadog Public endpoints.

The version of the OpenAPI document: 1.0
Contact: support@datadoghq.com
Generated by: https://openapi-generator.tech

 Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 This product includes software developed at Datadog (https://www.datadoghq.com/).
 Copyright 2020-Present Datadog, Inc.

=end

require 'cgi'

module DatadogAPIClient::V1
  class MonitorsAPI
    attr_accessor :api_client

    def initialize(api_client = APIClient.default)
      @api_client = api_client
    end

    # Check if a monitor can be deleted
    # Check if the given monitors can be deleted.
    # @param monitor_ids [Array<Integer>] The IDs of the monitor to check.
    # @param [Hash] opts the optional parameters
    # @return [CheckCanDeleteMonitorResponse]
    def check_can_delete_monitor(monitor_ids, opts = {})
      data, _status_code, _headers = check_can_delete_monitor_with_http_info(monitor_ids, opts)
      data
    end

    # Check if a monitor can be deleted
    # Check if the given monitors can be deleted.
    # @param monitor_ids [Array<Integer>] The IDs of the monitor to check.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CheckCanDeleteMonitorResponse, Integer, Hash)>] CheckCanDeleteMonitorResponse data, response status code and response headers
    def check_can_delete_monitor_with_http_info(monitor_ids, opts = {})

      if @api_client.config.unstable_operations.has_key?(:check_can_delete_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:check_can_delete_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "check_can_delete_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "check_can_delete_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.check_can_delete_monitor ...'
      end
      # verify the required parameter 'monitor_ids' is set
      if @api_client.config.client_side_validation && monitor_ids.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_ids' when calling MonitorsAPI.check_can_delete_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor/can_delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'monitor_ids'] = monitor_ids

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CheckCanDeleteMonitorResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :check_can_delete_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#check_can_delete_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a monitor
    # Create a monitor using the specified options.
    # 
    # #### Monitor Types
    # 
    # The type of monitor chosen from:
    # 
    # - anomaly: `query alert`
    # - APM: `query alert` or `trace-analytics alert`
    # - composite: `composite`
    # - custom: `service check`
    # - event: `event alert`
    # - forecast: `query alert`
    # - host: `service check`
    # - integration: `query alert` or `service check`
    # - live process: `process alert`
    # - logs: `log alert`
    # - metric: `query alert`
    # - network: `service check`
    # - outlier: `query alert`
    # - process: `service check`
    # - rum: `rum alert`
    # - SLO: `slo alert`
    # - watchdog: `event alert`
    # - event-v2: `event-v2 alert`
    # - audit: `audit alert`
    # 
    # #### Query Types
    # 
    # **Metric Alert Query**
    # 
    # Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
    # 
    # - `time_aggr`: avg, sum, max, min, change, or pct_change
    # - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
    # - `space_aggr`: avg, sum, min, or max
    # - `tags`: one or more tags (comma-separated), or *
    # - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
    # - `operator`: <, <=, >, >=, ==, or !=
    # - `#`: an integer or decimal number used to set the threshold
    # 
    # If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
    # timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
    # 
    # - `change_aggr` change, pct_change
    # - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
    # - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
    # - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
    # 
    # Use this to create an outlier monitor using the following query:
    # `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
    # 
    # **Service Check Query**
    # 
    # Example: `"check".over(tags).last(count).by(group).count_by_status()`
    # 
    # - **`check`** name of the check, for example `datadog.agent.up`
    # - **`tags`** one or more quoted tags (comma-separated), or "*". for example: `.over("env:prod", "role:db")`; **`over`** cannot be blank.
    # - **`count`** must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
    # For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
    # - **`group`** must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
    # For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
    # 
    # **Event Alert Query**
    # 
    # Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
    # 
    # - **`event`**, the event query string:
    # - **`string_query`** free text query to match against event title and text.
    # - **`sources`** event sources (comma-separated).
    # - **`status`** event statuses (comma-separated). Valid options: error, warn, and info.
    # - **`priority`** event priorities (comma-separated). Valid options: low, normal, all.
    # - **`host`** event reporting host (comma-separated).
    # - **`tags`** event tags (comma-separated).
    # - **`excluded_tags`** excluded event tags (comma-separated).
    # - **`rollup`** the stats roll-up method. `count` is the only supported method now.
    # - **`last`** the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
    # 
    # **NOTE** Only available on US1 and EU.
    # 
    # **Event V2 Alert Query**
    # 
    # Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available on US1-FED, US3, US5 and in closed beta on EU and US1.
    # 
    # **Process Alert Query**
    # 
    # Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
    # 
    # - **`search`** free text search string for querying processes.
    # Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
    # - **`tags`** one or more tags (comma-separated)
    # - **`timeframe`** the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
    # - **`operator`** <, <=, >, >=, ==, or !=
    # - **`#`** an integer or decimal number used to set the threshold
    # 
    # **Logs Alert Query**
    # 
    # Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`index_name`** For multi-index organizations, the log index in which the request is performed.
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **Composite Query**
    # 
    # Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
    # 
    # * **`name`** [*required*, *default* = **dynamic, based on query**]: The name of the alert.
    # * **`message`** [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
    # Email notifications can be sent to specific users by using the same '@username' notation as events.
    # * **`tags`** [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
    # When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
    # It is only available via the API and isn't visible or editable in the Datadog UI.
    # 
    # **SLO Alert Query**
    # 
    # Example: `error_budget("slo_id").over("time_window") operator #`
    # 
    # - **`slo_id`**: The alphanumeric SLO ID of the SLO you are configuring the alert for.
    # - **`time_window`**: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
    # - **`operator`**: `>=` or `>`
    # 
    # **Audit Alert Query**
    # 
    # Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
    # 
    # **CI Pipelines Alert Query**
    # 
    # Example: `ci-pipelines(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg`, and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available in closed beta on US1, EU, US3 and US5.
    # @param body [Monitor] Create a monitor request body.
    # @param [Hash] opts the optional parameters
    # @return [Monitor]
    def create_monitor(body, opts = {})
      data, _status_code, _headers = create_monitor_with_http_info(body, opts)
      data
    end

    # Create a monitor
    # Create a monitor using the specified options.
    # 
    # #### Monitor Types
    # 
    # The type of monitor chosen from:
    # 
    # - anomaly: `query alert`
    # - APM: `query alert` or `trace-analytics alert`
    # - composite: `composite`
    # - custom: `service check`
    # - event: `event alert`
    # - forecast: `query alert`
    # - host: `service check`
    # - integration: `query alert` or `service check`
    # - live process: `process alert`
    # - logs: `log alert`
    # - metric: `query alert`
    # - network: `service check`
    # - outlier: `query alert`
    # - process: `service check`
    # - rum: `rum alert`
    # - SLO: `slo alert`
    # - watchdog: `event alert`
    # - event-v2: `event-v2 alert`
    # - audit: `audit alert`
    # 
    # #### Query Types
    # 
    # **Metric Alert Query**
    # 
    # Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
    # 
    # - `time_aggr`: avg, sum, max, min, change, or pct_change
    # - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
    # - `space_aggr`: avg, sum, min, or max
    # - `tags`: one or more tags (comma-separated), or *
    # - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
    # - `operator`: <, <=, >, >=, ==, or !=
    # - `#`: an integer or decimal number used to set the threshold
    # 
    # If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
    # timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
    # 
    # - `change_aggr` change, pct_change
    # - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
    # - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
    # - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
    # 
    # Use this to create an outlier monitor using the following query:
    # `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
    # 
    # **Service Check Query**
    # 
    # Example: `"check".over(tags).last(count).by(group).count_by_status()`
    # 
    # - **`check`** name of the check, for example `datadog.agent.up`
    # - **`tags`** one or more quoted tags (comma-separated), or "*". for example: `.over("env:prod", "role:db")`; **`over`** cannot be blank.
    # - **`count`** must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
    # For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
    # - **`group`** must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
    # For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
    # 
    # **Event Alert Query**
    # 
    # Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
    # 
    # - **`event`**, the event query string:
    # - **`string_query`** free text query to match against event title and text.
    # - **`sources`** event sources (comma-separated).
    # - **`status`** event statuses (comma-separated). Valid options: error, warn, and info.
    # - **`priority`** event priorities (comma-separated). Valid options: low, normal, all.
    # - **`host`** event reporting host (comma-separated).
    # - **`tags`** event tags (comma-separated).
    # - **`excluded_tags`** excluded event tags (comma-separated).
    # - **`rollup`** the stats roll-up method. `count` is the only supported method now.
    # - **`last`** the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
    # 
    # **NOTE** Only available on US1 and EU.
    # 
    # **Event V2 Alert Query**
    # 
    # Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available on US1-FED, US3, US5 and in closed beta on EU and US1.
    # 
    # **Process Alert Query**
    # 
    # Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
    # 
    # - **`search`** free text search string for querying processes.
    # Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
    # - **`tags`** one or more tags (comma-separated)
    # - **`timeframe`** the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
    # - **`operator`** <, <=, >, >=, ==, or !=
    # - **`#`** an integer or decimal number used to set the threshold
    # 
    # **Logs Alert Query**
    # 
    # Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`index_name`** For multi-index organizations, the log index in which the request is performed.
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **Composite Query**
    # 
    # Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
    # 
    # * **`name`** [*required*, *default* = **dynamic, based on query**]: The name of the alert.
    # * **`message`** [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
    # Email notifications can be sent to specific users by using the same '@username' notation as events.
    # * **`tags`** [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
    # When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
    # It is only available via the API and isn't visible or editable in the Datadog UI.
    # 
    # **SLO Alert Query**
    # 
    # Example: `error_budget("slo_id").over("time_window") operator #`
    # 
    # - **`slo_id`**: The alphanumeric SLO ID of the SLO you are configuring the alert for.
    # - **`time_window`**: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
    # - **`operator`**: `>=` or `>`
    # 
    # **Audit Alert Query**
    # 
    # Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg` and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
    # 
    # **CI Pipelines Alert Query**
    # 
    # Example: `ci-pipelines(query).rollup(rollup_method[, measure]).last(time_window) operator #`
    # 
    # - **`query`** The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
    # - **`rollup_method`** The stats roll-up method - supports `count`, `avg`, and `cardinality`.
    # - **`measure`** For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
    # - **`time_window`** #m (between 1 and 2880), #h (between 1 and 48).
    # - **`operator`** `<`, `<=`, `>`, `>=`, `==`, or `!=`.
    # - **`#`** an integer or decimal number used to set the threshold.
    # 
    # **NOTE** Only available in closed beta on US1, EU, US3 and US5.
    # @param body [Monitor] Create a monitor request body.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Monitor, Integer, Hash)>] Monitor data, response status code and response headers
    def create_monitor_with_http_info(body, opts = {})

      if @api_client.config.unstable_operations.has_key?(:create_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:create_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "create_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "create_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.create_monitor ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling MonitorsAPI.create_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'Monitor'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :create_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#create_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a monitor
    # Delete the specified monitor
    # @param monitor_id [Integer] The ID of the monitor.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :force Delete the monitor even if it's referenced by other resources (for example SLO, composite monitor).
    # @return [DeletedMonitor]
    def delete_monitor(monitor_id, opts = {})
      data, _status_code, _headers = delete_monitor_with_http_info(monitor_id, opts)
      data
    end

    # Delete a monitor
    # Delete the specified monitor
    # @param monitor_id [Integer] The ID of the monitor.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :force Delete the monitor even if it's referenced by other resources (for example SLO, composite monitor).
    # @return [Array<(DeletedMonitor, Integer, Hash)>] DeletedMonitor data, response status code and response headers
    def delete_monitor_with_http_info(monitor_id, opts = {})

      if @api_client.config.unstable_operations.has_key?(:delete_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:delete_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "delete_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "delete_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.delete_monitor ...'
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling MonitorsAPI.delete_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor/{monitor_id}'.sub('{monitor_id}', CGI.escape(monitor_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'force'] = opts[:'force'] if !opts[:'force'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeletedMonitor'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#delete_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a monitor's details
    # Get details about the specified monitor from your organization.
    # @param monitor_id [Integer] The ID of the monitor
    # @param [Hash] opts the optional parameters
    # @option opts [String] :group_states When specified, shows additional information about the group states. Choose one or more from `all`, `alert`, `warn`, and `no data`.
    # @return [Monitor]
    def get_monitor(monitor_id, opts = {})
      data, _status_code, _headers = get_monitor_with_http_info(monitor_id, opts)
      data
    end

    # Get a monitor's details
    # Get details about the specified monitor from your organization.
    # @param monitor_id [Integer] The ID of the monitor
    # @param [Hash] opts the optional parameters
    # @option opts [String] :group_states When specified, shows additional information about the group states. Choose one or more from `all`, `alert`, `warn`, and `no data`.
    # @return [Array<(Monitor, Integer, Hash)>] Monitor data, response status code and response headers
    def get_monitor_with_http_info(monitor_id, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:get_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.get_monitor ...'
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling MonitorsAPI.get_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor/{monitor_id}'.sub('{monitor_id}', CGI.escape(monitor_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'group_states'] = opts[:'group_states'] if !opts[:'group_states'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Monitor'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#get_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all monitor details
    # Get details about the specified monitor from your organization.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :group_states When specified, shows additional information about the group states. Choose one or more from `all`, `alert`, `warn`, and `no data`.
    # @option opts [String] :name A string to filter monitors by name.
    # @option opts [String] :tags A comma separated list indicating what tags, if any, should be used to filter the list of monitors by scope. For example, `host:host0`.
    # @option opts [String] :monitor_tags A comma separated list indicating what service and/or custom tags, if any, should be used to filter the list of monitors. Tags created in the Datadog UI automatically have the service key prepended. For example, `service:my-app`.
    # @option opts [Boolean] :with_downtimes If this argument is set to true, then the returned data includes all current active downtimes for each monitor.
    # @option opts [Integer] :id_offset Use this parameter for paginating through large sets of monitors. Start with a value of zero, make a request, set the value to the last ID of result set, and then repeat until the response is empty.
    # @option opts [Integer] :page The page to start paginating from. If this argument is not specified, the request returns all monitors without pagination.
    # @option opts [Integer] :page_size The number of monitors to return per page. If the page argument is not specified, the default behavior returns all monitors without a `page_size` limit. However, if page is specified and `page_size` is not, the argument defaults to 100.
    # @return [Array<Monitor>]
    def list_monitors(opts = {})
      data, _status_code, _headers = list_monitors_with_http_info(opts)
      data
    end

    # Get all monitor details
    # Get details about the specified monitor from your organization.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :group_states When specified, shows additional information about the group states. Choose one or more from `all`, `alert`, `warn`, and `no data`.
    # @option opts [String] :name A string to filter monitors by name.
    # @option opts [String] :tags A comma separated list indicating what tags, if any, should be used to filter the list of monitors by scope. For example, `host:host0`.
    # @option opts [String] :monitor_tags A comma separated list indicating what service and/or custom tags, if any, should be used to filter the list of monitors. Tags created in the Datadog UI automatically have the service key prepended. For example, `service:my-app`.
    # @option opts [Boolean] :with_downtimes If this argument is set to true, then the returned data includes all current active downtimes for each monitor.
    # @option opts [Integer] :id_offset Use this parameter for paginating through large sets of monitors. Start with a value of zero, make a request, set the value to the last ID of result set, and then repeat until the response is empty.
    # @option opts [Integer] :page The page to start paginating from. If this argument is not specified, the request returns all monitors without pagination.
    # @option opts [Integer] :page_size The number of monitors to return per page. If the page argument is not specified, the default behavior returns all monitors without a `page_size` limit. However, if page is specified and `page_size` is not, the argument defaults to 100.
    # @return [Array<(Array<Monitor>, Integer, Hash)>] Array<Monitor> data, response status code and response headers
    def list_monitors_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:list_monitors)
        unstable_enabled = @api_client.config.unstable_operations[:list_monitors]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "list_monitors")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "list_monitors"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.list_monitors ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling MonitorsAPI.ListMonitors, must be smaller than or equal to 1000.'
      end
      # resource path
      local_var_path = '/api/v1/monitor'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'group_states'] = opts[:'group_states'] if !opts[:'group_states'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?
      query_params[:'monitor_tags'] = opts[:'monitor_tags'] if !opts[:'monitor_tags'].nil?
      query_params[:'with_downtimes'] = opts[:'with_downtimes'] if !opts[:'with_downtimes'].nil?
      query_params[:'id_offset'] = opts[:'id_offset'] if !opts[:'id_offset'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Monitor>'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_monitors,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#list_monitors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Monitors group search
    # Search and filter your monitor groups details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :query After entering a search query in your [Manage Monitor page][1] use the query parameter value in the URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2] page to learn more.  The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.  [1]: https://app.datadoghq.com/monitors/manage [2]: /monitors/manage/#find-the-monitors
    # @option opts [Integer] :page Page to start paginating from.
    # @option opts [Integer] :per_page Number of monitors to return per page.
    # @option opts [String] :sort String for sort order, composed of field and sort order separate by a comma, for example `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:  * `name` * `status` * `tags`
    # @return [MonitorGroupSearchResponse]
    def search_monitor_groups(opts = {})
      data, _status_code, _headers = search_monitor_groups_with_http_info(opts)
      data
    end

    # Monitors group search
    # Search and filter your monitor groups details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :query After entering a search query in your [Manage Monitor page][1] use the query parameter value in the URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2] page to learn more.  The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.  [1]: https://app.datadoghq.com/monitors/manage [2]: /monitors/manage/#find-the-monitors
    # @option opts [Integer] :page Page to start paginating from.
    # @option opts [Integer] :per_page Number of monitors to return per page.
    # @option opts [String] :sort String for sort order, composed of field and sort order separate by a comma, for example `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:  * `name` * `status` * `tags`
    # @return [Array<(MonitorGroupSearchResponse, Integer, Hash)>] MonitorGroupSearchResponse data, response status code and response headers
    def search_monitor_groups_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:search_monitor_groups)
        unstable_enabled = @api_client.config.unstable_operations[:search_monitor_groups]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "search_monitor_groups")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "search_monitor_groups"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.search_monitor_groups ...'
      end
      # resource path
      local_var_path = '/api/v1/monitor/groups/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'query'] = opts[:'query'] if !opts[:'query'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'per_page'] = opts[:'per_page'] if !opts[:'per_page'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MonitorGroupSearchResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :search_monitor_groups,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#search_monitor_groups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Monitors search
    # Search and filter your monitors details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :query After entering a search query in your [Manage Monitor page][1] use the query parameter value in the URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2] page to learn more.  The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.  [1]: https://app.datadoghq.com/monitors/manage [2]: /monitors/manage/#find-the-monitors
    # @option opts [Integer] :page Page to start paginating from.
    # @option opts [Integer] :per_page Number of monitors to return per page.
    # @option opts [String] :sort String for sort order, composed of field and sort order separate by a comma, for example `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:  * `name` * `status` * `tags`
    # @return [MonitorSearchResponse]
    def search_monitors(opts = {})
      data, _status_code, _headers = search_monitors_with_http_info(opts)
      data
    end

    # Monitors search
    # Search and filter your monitors details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :query After entering a search query in your [Manage Monitor page][1] use the query parameter value in the URL of the page as value for this parameter. Consult the dedicated [manage monitor documentation][2] page to learn more.  The query can contain any number of space-separated monitor attributes, for instance `query="type:metric status:alert"`.  [1]: https://app.datadoghq.com/monitors/manage [2]: /monitors/manage/#find-the-monitors
    # @option opts [Integer] :page Page to start paginating from.
    # @option opts [Integer] :per_page Number of monitors to return per page.
    # @option opts [String] :sort String for sort order, composed of field and sort order separate by a comma, for example `name,asc`. Supported sort directions: `asc`, `desc`. Supported fields:  * `name` * `status` * `tags`
    # @return [Array<(MonitorSearchResponse, Integer, Hash)>] MonitorSearchResponse data, response status code and response headers
    def search_monitors_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:search_monitors)
        unstable_enabled = @api_client.config.unstable_operations[:search_monitors]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "search_monitors")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "search_monitors"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.search_monitors ...'
      end
      # resource path
      local_var_path = '/api/v1/monitor/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'query'] = opts[:'query'] if !opts[:'query'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'per_page'] = opts[:'per_page'] if !opts[:'per_page'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MonitorSearchResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :search_monitors,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#search_monitors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Edit a monitor
    # Edit the specified monitor.
    # @param monitor_id [Integer] The ID of the monitor.
    # @param body [MonitorUpdateRequest] Edit a monitor request body.
    # @param [Hash] opts the optional parameters
    # @return [Monitor]
    def update_monitor(monitor_id, body, opts = {})
      data, _status_code, _headers = update_monitor_with_http_info(monitor_id, body, opts)
      data
    end

    # Edit a monitor
    # Edit the specified monitor.
    # @param monitor_id [Integer] The ID of the monitor.
    # @param body [MonitorUpdateRequest] Edit a monitor request body.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Monitor, Integer, Hash)>] Monitor data, response status code and response headers
    def update_monitor_with_http_info(monitor_id, body, opts = {})

      if @api_client.config.unstable_operations.has_key?(:update_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:update_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "update_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "update_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.update_monitor ...'
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling MonitorsAPI.update_monitor"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling MonitorsAPI.update_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor/{monitor_id}'.sub('{monitor_id}', CGI.escape(monitor_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'Monitor'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#update_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Validate a monitor
    # Validate the monitor provided in the request.
    # @param body [Monitor] Monitor request object
    # @param [Hash] opts the optional parameters
    # @return [Object]
    def validate_monitor(body, opts = {})
      data, _status_code, _headers = validate_monitor_with_http_info(body, opts)
      data
    end

    # Validate a monitor
    # Validate the monitor provided in the request.
    # @param body [Monitor] Monitor request object
    # @param [Hash] opts the optional parameters
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def validate_monitor_with_http_info(body, opts = {})

      if @api_client.config.unstable_operations.has_key?(:validate_monitor)
        unstable_enabled = @api_client.config.unstable_operations[:validate_monitor]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "validate_monitor")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "validate_monitor"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MonitorsAPI.validate_monitor ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling MonitorsAPI.validate_monitor"
      end
      # resource path
      local_var_path = '/api/v1/monitor/validate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'Object'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :validate_monitor,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MonitorsAPI#validate_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
