=begin
#Datadog API V1 Collection

#Collection of all Datadog Public endpoints.

The version of the OpenAPI document: 1.0
Contact: support@datadoghq.com
Generated by: https://github.com/DataDog/datadog-api-client-ruby/tree/master/.generator

 Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 This product includes software developed at Datadog (https://www.datadoghq.com/).
 Copyright 2020-Present Datadog, Inc.

=end

require 'cgi'

module DatadogAPIClient::V1
  class UsageMeteringAPI
    attr_accessor :api_client

    def initialize(api_client = APIClient.default)
      @api_client = api_client
    end

    # Get the list of available daily custom reports
    # Get daily custom reports.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size The number of files to return in the response. `[default=60]`.
    # @option opts [Integer] :page_number The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
    # @option opts [UsageSortDirection] :sort_dir The direction to sort by: `[desc, asc]`.
    # @option opts [UsageSort] :sort The field to sort by: `[computed_on, size, start_date, end_date]`.
    # @return [UsageCustomReportsResponse]
    def get_daily_custom_reports(opts = {})
      data, _status_code, _headers = get_daily_custom_reports_with_http_info(opts)
      data
    end

    # Get the list of available daily custom reports
    # Get daily custom reports.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size The number of files to return in the response. `[default=60]`.
    # @option opts [Integer] :page_number The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
    # @option opts [UsageSortDirection] :sort_dir The direction to sort by: `[desc, asc]`.
    # @option opts [UsageSort] :sort The field to sort by: `[computed_on, size, start_date, end_date]`.
    # @return [Array<(UsageCustomReportsResponse, Integer, Hash)>] UsageCustomReportsResponse data, response status code and response headers
    def get_daily_custom_reports_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_daily_custom_reports)
        unstable_enabled = @api_client.config.unstable_operations[:get_daily_custom_reports]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_daily_custom_reports")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_daily_custom_reports"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_daily_custom_reports ...'
      end
      allowable_values = ['desc', 'asc']
      if @api_client.config.client_side_validation && opts[:'sort_dir'] && !allowable_values.include?(opts[:'sort_dir'])
        fail ArgumentError, "invalid value for \"sort_dir\", must be one of #{allowable_values}"
      end
      allowable_values = ['computed_on', 'size', 'start_date', 'end_date']
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v1/daily_custom_reports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[size]'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'sort_dir'] = opts[:'sort_dir'] if !opts[:'sort_dir'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageCustomReportsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_daily_custom_reports,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_daily_custom_reports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Hourly Usage Attribution
    # Get Hourly Usage Attribution.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param usage_type [HourlyUsageAttributionUsageType] Usage type to retrieve.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @option opts [String] :tag_breakdown_keys Comma separated list of tags used to group usage. If no value is provided the usage will not be broken down by tags.
    # @return [HourlyUsageAttributionResponse]
    def get_hourly_usage_attribution(start_hr, usage_type, opts = {})
      data, _status_code, _headers = get_hourly_usage_attribution_with_http_info(start_hr, usage_type, opts)
      data
    end

    # Get Hourly Usage Attribution
    # Get Hourly Usage Attribution.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param usage_type [HourlyUsageAttributionUsageType] Usage type to retrieve.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @option opts [String] :tag_breakdown_keys Comma separated list of tags used to group usage. If no value is provided the usage will not be broken down by tags.
    # @return [Array<(HourlyUsageAttributionResponse, Integer, Hash)>] HourlyUsageAttributionResponse data, response status code and response headers
    def get_hourly_usage_attribution_with_http_info(start_hr, usage_type, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_hourly_usage_attribution)
        unstable_enabled = @api_client.config.unstable_operations[:get_hourly_usage_attribution]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_hourly_usage_attribution")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_hourly_usage_attribution"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_hourly_usage_attribution ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_hourly_usage_attribution"
      end
      # verify the required parameter 'usage_type' is set
      if @api_client.config.client_side_validation && usage_type.nil?
        fail ArgumentError, "Missing the required parameter 'usage_type' when calling UsageMeteringAPI.get_hourly_usage_attribution"
      end
      # verify enum value
      allowable_values = ['api_usage', 'apm_host_usage', 'browser_usage', 'container_usage', 'custom_timeseries_usage', 'estimated_indexed_logs_usage', 'fargate_usage', 'functions_usage', 'indexed_logs_usage', 'infra_host_usage', 'invocations_usage', 'npm_host_usage', 'profiled_container_usage', 'profiled_host_usage', 'snmp_usage']
      if @api_client.config.client_side_validation && !allowable_values.include?(usage_type)
        fail ArgumentError, "invalid value for \"usage_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v1/usage/hourly-attribution'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'usage_type'] = usage_type
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?
      query_params[:'next_record_id'] = opts[:'next_record_id'] if !opts[:'next_record_id'].nil?
      query_params[:'tag_breakdown_keys'] = opts[:'tag_breakdown_keys'] if !opts[:'tag_breakdown_keys'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'HourlyUsageAttributionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_hourly_usage_attribution,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_hourly_usage_attribution\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for incident management
    # Get hourly usage for incident management.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageIncidentManagementResponse]
    def get_incident_management(start_hr, opts = {})
      data, _status_code, _headers = get_incident_management_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for incident management
    # Get hourly usage for incident management.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageIncidentManagementResponse, Integer, Hash)>] UsageIncidentManagementResponse data, response status code and response headers
    def get_incident_management_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_incident_management)
        unstable_enabled = @api_client.config.unstable_operations[:get_incident_management]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_incident_management")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_incident_management"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_incident_management ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_incident_management"
      end
      # resource path
      local_var_path = '/api/v1/usage/incident-management'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageIncidentManagementResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_incident_management,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_incident_management\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for ingested spans
    # Get hourly usage for ingested spans.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageIngestedSpansResponse]
    def get_ingested_spans(start_hr, opts = {})
      data, _status_code, _headers = get_ingested_spans_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for ingested spans
    # Get hourly usage for ingested spans.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageIngestedSpansResponse, Integer, Hash)>] UsageIngestedSpansResponse data, response status code and response headers
    def get_ingested_spans_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_ingested_spans)
        unstable_enabled = @api_client.config.unstable_operations[:get_ingested_spans]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_ingested_spans")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_ingested_spans"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_ingested_spans ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_ingested_spans"
      end
      # resource path
      local_var_path = '/api/v1/usage/ingested-spans'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageIngestedSpansResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_ingested_spans,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_ingested_spans\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the list of available monthly custom reports
    # Get monthly custom reports.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size The number of files to return in the response `[default=60].`
    # @option opts [Integer] :page_number The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
    # @option opts [UsageSortDirection] :sort_dir The direction to sort by: `[desc, asc]`.
    # @option opts [UsageSort] :sort The field to sort by: `[computed_on, size, start_date, end_date]`.
    # @return [UsageCustomReportsResponse]
    def get_monthly_custom_reports(opts = {})
      data, _status_code, _headers = get_monthly_custom_reports_with_http_info(opts)
      data
    end

    # Get the list of available monthly custom reports
    # Get monthly custom reports.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size The number of files to return in the response `[default=60].`
    # @option opts [Integer] :page_number The identifier of the first page to return. This parameter is used for the pagination feature `[default=0]`.
    # @option opts [UsageSortDirection] :sort_dir The direction to sort by: `[desc, asc]`.
    # @option opts [UsageSort] :sort The field to sort by: `[computed_on, size, start_date, end_date]`.
    # @return [Array<(UsageCustomReportsResponse, Integer, Hash)>] UsageCustomReportsResponse data, response status code and response headers
    def get_monthly_custom_reports_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_monthly_custom_reports)
        unstable_enabled = @api_client.config.unstable_operations[:get_monthly_custom_reports]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_monthly_custom_reports")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_monthly_custom_reports"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_monthly_custom_reports ...'
      end
      allowable_values = ['desc', 'asc']
      if @api_client.config.client_side_validation && opts[:'sort_dir'] && !allowable_values.include?(opts[:'sort_dir'])
        fail ArgumentError, "invalid value for \"sort_dir\", must be one of #{allowable_values}"
      end
      allowable_values = ['computed_on', 'size', 'start_date', 'end_date']
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v1/monthly_custom_reports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[size]'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'sort_dir'] = opts[:'sort_dir'] if !opts[:'sort_dir'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageCustomReportsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_monthly_custom_reports,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_monthly_custom_reports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Monthly Usage Attribution
    # Get Monthly Usage Attribution.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param fields [MonthlyUsageAttributionSupportedMetrics] Comma-separated list of usage types to return, or `*` for all usage types.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [UsageSortDirection] :sort_direction The direction to sort by: `[desc, asc]`.
    # @option opts [MonthlyUsageAttributionSupportedMetrics] :sort_name The field to sort by.
    # @option opts [String] :tag_breakdown_keys Comma separated list of tags used to group usage. If no value is provided the usage will not be broken down by tags.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @return [MonthlyUsageAttributionResponse]
    def get_monthly_usage_attribution(start_month, fields, opts = {})
      data, _status_code, _headers = get_monthly_usage_attribution_with_http_info(start_month, fields, opts)
      data
    end

    # Get Monthly Usage Attribution
    # Get Monthly Usage Attribution.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param fields [MonthlyUsageAttributionSupportedMetrics] Comma-separated list of usage types to return, or `*` for all usage types.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [UsageSortDirection] :sort_direction The direction to sort by: `[desc, asc]`.
    # @option opts [MonthlyUsageAttributionSupportedMetrics] :sort_name The field to sort by.
    # @option opts [String] :tag_breakdown_keys Comma separated list of tags used to group usage. If no value is provided the usage will not be broken down by tags.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @return [Array<(MonthlyUsageAttributionResponse, Integer, Hash)>] MonthlyUsageAttributionResponse data, response status code and response headers
    def get_monthly_usage_attribution_with_http_info(start_month, fields, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_monthly_usage_attribution)
        unstable_enabled = @api_client.config.unstable_operations[:get_monthly_usage_attribution]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_monthly_usage_attribution")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_monthly_usage_attribution"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_monthly_usage_attribution ...'
      end
      # verify the required parameter 'start_month' is set
      if @api_client.config.client_side_validation && start_month.nil?
        fail ArgumentError, "Missing the required parameter 'start_month' when calling UsageMeteringAPI.get_monthly_usage_attribution"
      end
      # verify the required parameter 'fields' is set
      if @api_client.config.client_side_validation && fields.nil?
        fail ArgumentError, "Missing the required parameter 'fields' when calling UsageMeteringAPI.get_monthly_usage_attribution"
      end
      # verify enum value
      allowable_values = ['api_usage', 'api_percentage', 'apm_host_usage', 'apm_host_percentage', 'browser_usage', 'browser_percentage', 'container_usage', 'container_percentage', 'custom_timeseries_usage', 'custom_timeseries_percentage', 'estimated_indexed_logs_usage', 'estimated_indexed_logs_percentage', 'fargate_usage', 'fargate_percentage', 'functions_usage', 'functions_percentage', 'indexed_logs_usage', 'indexed_logs_percentage', 'infra_host_usage', 'infra_host_percentage', 'invocations_usage', 'invocations_percentage', 'npm_host_usage', 'npm_host_percentage', 'profiled_container_usage', 'profiled_container_percentage', 'profiled_host_usage', 'profiled_host_percentage', 'snmp_usage', 'snmp_percentage', '*']
      if @api_client.config.client_side_validation && !allowable_values.include?(fields)
        fail ArgumentError, "invalid value for \"fields\", must be one of #{allowable_values}"
      end
      allowable_values = ['desc', 'asc']
      if @api_client.config.client_side_validation && opts[:'sort_direction'] && !allowable_values.include?(opts[:'sort_direction'])
        fail ArgumentError, "invalid value for \"sort_direction\", must be one of #{allowable_values}"
      end
      allowable_values = ['api_usage', 'api_percentage', 'apm_host_usage', 'apm_host_percentage', 'browser_usage', 'browser_percentage', 'container_usage', 'container_percentage', 'custom_timeseries_usage', 'custom_timeseries_percentage', 'estimated_indexed_logs_usage', 'estimated_indexed_logs_percentage', 'fargate_usage', 'fargate_percentage', 'functions_usage', 'functions_percentage', 'indexed_logs_usage', 'indexed_logs_percentage', 'infra_host_usage', 'infra_host_percentage', 'invocations_usage', 'invocations_percentage', 'npm_host_usage', 'npm_host_percentage', 'profiled_container_usage', 'profiled_container_percentage', 'profiled_host_usage', 'profiled_host_percentage', 'snmp_usage', 'snmp_percentage', '*']
      if @api_client.config.client_side_validation && opts[:'sort_name'] && !allowable_values.include?(opts[:'sort_name'])
        fail ArgumentError, "invalid value for \"sort_name\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v1/usage/monthly-attribution'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_month'] = start_month
      query_params[:'fields'] = fields
      query_params[:'end_month'] = opts[:'end_month'] if !opts[:'end_month'].nil?
      query_params[:'sort_direction'] = opts[:'sort_direction'] if !opts[:'sort_direction'].nil?
      query_params[:'sort_name'] = opts[:'sort_name'] if !opts[:'sort_name'].nil?
      query_params[:'tag_breakdown_keys'] = opts[:'tag_breakdown_keys'] if !opts[:'tag_breakdown_keys'].nil?
      query_params[:'next_record_id'] = opts[:'next_record_id'] if !opts[:'next_record_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MonthlyUsageAttributionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_monthly_usage_attribution,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_monthly_usage_attribution\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get specified daily custom reports
    # Get specified daily custom reports.
    # @param report_id [String] Date of the report in the format `YYYY-MM-DD`.
    # @param opts [Hash] the optional parameters
    # @return [UsageSpecifiedCustomReportsResponse]
    def get_specified_daily_custom_reports(report_id, opts = {})
      data, _status_code, _headers = get_specified_daily_custom_reports_with_http_info(report_id, opts)
      data
    end

    # Get specified daily custom reports
    # Get specified daily custom reports.
    # @param report_id [String] Date of the report in the format `YYYY-MM-DD`.
    # @param opts [Hash] the optional parameters
    # @return [Array<(UsageSpecifiedCustomReportsResponse, Integer, Hash)>] UsageSpecifiedCustomReportsResponse data, response status code and response headers
    def get_specified_daily_custom_reports_with_http_info(report_id, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_specified_daily_custom_reports)
        unstable_enabled = @api_client.config.unstable_operations[:get_specified_daily_custom_reports]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_specified_daily_custom_reports")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_specified_daily_custom_reports"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_specified_daily_custom_reports ...'
      end
      # verify the required parameter 'report_id' is set
      if @api_client.config.client_side_validation && report_id.nil?
        fail ArgumentError, "Missing the required parameter 'report_id' when calling UsageMeteringAPI.get_specified_daily_custom_reports"
      end
      # resource path
      local_var_path = '/api/v1/daily_custom_reports/{report_id}'.sub('{report_id}', CGI.escape(report_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSpecifiedCustomReportsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_specified_daily_custom_reports,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_specified_daily_custom_reports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get specified monthly custom reports
    # Get specified monthly custom reports.
    # @param report_id [String] Date of the report in the format `YYYY-MM-DD`.
    # @param opts [Hash] the optional parameters
    # @return [UsageSpecifiedCustomReportsResponse]
    def get_specified_monthly_custom_reports(report_id, opts = {})
      data, _status_code, _headers = get_specified_monthly_custom_reports_with_http_info(report_id, opts)
      data
    end

    # Get specified monthly custom reports
    # Get specified monthly custom reports.
    # @param report_id [String] Date of the report in the format `YYYY-MM-DD`.
    # @param opts [Hash] the optional parameters
    # @return [Array<(UsageSpecifiedCustomReportsResponse, Integer, Hash)>] UsageSpecifiedCustomReportsResponse data, response status code and response headers
    def get_specified_monthly_custom_reports_with_http_info(report_id, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_specified_monthly_custom_reports)
        unstable_enabled = @api_client.config.unstable_operations[:get_specified_monthly_custom_reports]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_specified_monthly_custom_reports")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_specified_monthly_custom_reports"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_specified_monthly_custom_reports ...'
      end
      # verify the required parameter 'report_id' is set
      if @api_client.config.client_side_validation && report_id.nil?
        fail ArgumentError, "Missing the required parameter 'report_id' when calling UsageMeteringAPI.get_specified_monthly_custom_reports"
      end
      # resource path
      local_var_path = '/api/v1/monthly_custom_reports/{report_id}'.sub('{report_id}', CGI.escape(report_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSpecifiedCustomReportsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_specified_monthly_custom_reports,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_specified_monthly_custom_reports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for analyzed logs
    # Get hourly usage for analyzed logs (Security Monitoring).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageAnalyzedLogsResponse]
    def get_usage_analyzed_logs(start_hr, opts = {})
      data, _status_code, _headers = get_usage_analyzed_logs_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for analyzed logs
    # Get hourly usage for analyzed logs (Security Monitoring).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageAnalyzedLogsResponse, Integer, Hash)>] UsageAnalyzedLogsResponse data, response status code and response headers
    def get_usage_analyzed_logs_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_analyzed_logs)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_analyzed_logs]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_analyzed_logs")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_analyzed_logs"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_analyzed_logs ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_analyzed_logs"
      end
      # resource path
      local_var_path = '/api/v1/usage/analyzed_logs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageAnalyzedLogsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_analyzed_logs,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_analyzed_logs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Usage Attribution
    # Get Usage Attribution.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param fields [UsageAttributionSupportedMetrics] Comma-separated list of usage types to return, or `*` for all usage types.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [UsageSortDirection] :sort_direction The direction to sort by: `[desc, asc]`.
    # @option opts [UsageAttributionSort] :sort_name The field to sort by.
    # @option opts [Boolean] :include_descendants Include child org usage in the response. Defaults to false.
    # @option opts [Integer] :offset Number of records to skip before beginning to return.
    # @option opts [Integer] :limit Maximum number of records to be returned.
    # @return [UsageAttributionResponse]
    def get_usage_attribution(start_month, fields, opts = {})
      data, _status_code, _headers = get_usage_attribution_with_http_info(start_month, fields, opts)
      data
    end

    # Get Usage Attribution
    # Get Usage Attribution.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param fields [UsageAttributionSupportedMetrics] Comma-separated list of usage types to return, or `*` for all usage types.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [UsageSortDirection] :sort_direction The direction to sort by: `[desc, asc]`.
    # @option opts [UsageAttributionSort] :sort_name The field to sort by.
    # @option opts [Boolean] :include_descendants Include child org usage in the response. Defaults to false.
    # @option opts [Integer] :offset Number of records to skip before beginning to return.
    # @option opts [Integer] :limit Maximum number of records to be returned.
    # @return [Array<(UsageAttributionResponse, Integer, Hash)>] UsageAttributionResponse data, response status code and response headers
    def get_usage_attribution_with_http_info(start_month, fields, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_attribution)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_attribution]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_attribution")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_attribution"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_attribution ...'
      end
      # verify the required parameter 'start_month' is set
      if @api_client.config.client_side_validation && start_month.nil?
        fail ArgumentError, "Missing the required parameter 'start_month' when calling UsageMeteringAPI.get_usage_attribution"
      end
      # verify the required parameter 'fields' is set
      if @api_client.config.client_side_validation && fields.nil?
        fail ArgumentError, "Missing the required parameter 'fields' when calling UsageMeteringAPI.get_usage_attribution"
      end
      # verify enum value
      allowable_values = ['custom_timeseries_usage', 'container_usage', 'snmp_percentage', 'apm_host_usage', 'browser_usage', 'npm_host_percentage', 'infra_host_usage', 'custom_timeseries_percentage', 'container_percentage', 'lambda_usage', 'api_usage', 'apm_host_percentage', 'infra_host_percentage', 'snmp_usage', 'browser_percentage', 'api_percentage', 'lambda_percentage', 'npm_host_usage', 'lambda_functions_usage', 'lambda_functions_percentage', 'lambda_invocations_usage', 'lambda_invocations_percentage', 'fargate_usage', 'fargate_percentage', 'profiled_host_usage', 'profiled_host_percentage', 'profiled_container_usage', 'profiled_container_percentage', 'dbm_hosts_usage', 'dbm_hosts_percentage', 'dbm_queries_usage', 'dbm_queries_percentage', 'estimated_indexed_logs_usage', 'estimated_indexed_logs_percentage', '*']
      if @api_client.config.client_side_validation && !allowable_values.include?(fields)
        fail ArgumentError, "invalid value for \"fields\", must be one of #{allowable_values}"
      end
      allowable_values = ['desc', 'asc']
      if @api_client.config.client_side_validation && opts[:'sort_direction'] && !allowable_values.include?(opts[:'sort_direction'])
        fail ArgumentError, "invalid value for \"sort_direction\", must be one of #{allowable_values}"
      end
      allowable_values = ['api_percentage', 'snmp_usage', 'apm_host_usage', 'api_usage', 'container_usage', 'custom_timeseries_percentage', 'container_percentage', 'apm_host_percentage', 'npm_host_percentage', 'browser_percentage', 'browser_usage', 'infra_host_percentage', 'snmp_percentage', 'npm_host_usage', 'infra_host_usage', 'custom_timeseries_usage', 'lambda_functions_usage', 'lambda_functions_percentage', 'lambda_invocations_usage', 'lambda_invocations_percentage', 'lambda_usage', 'lambda_percentage', 'estimated_indexed_logs_usage', 'estimated_indexed_logs_percentage']
      if @api_client.config.client_side_validation && opts[:'sort_name'] && !allowable_values.include?(opts[:'sort_name'])
        fail ArgumentError, "invalid value for \"sort_name\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v1/usage/attribution'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_month'] = start_month
      query_params[:'fields'] = fields
      query_params[:'end_month'] = opts[:'end_month'] if !opts[:'end_month'].nil?
      query_params[:'sort_direction'] = opts[:'sort_direction'] if !opts[:'sort_direction'].nil?
      query_params[:'sort_name'] = opts[:'sort_name'] if !opts[:'sort_name'].nil?
      query_params[:'include_descendants'] = opts[:'include_descendants'] if !opts[:'include_descendants'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageAttributionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_attribution,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_attribution\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for audit logs
    # Get hourly usage for audit logs.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageAuditLogsResponse]
    def get_usage_audit_logs(start_hr, opts = {})
      data, _status_code, _headers = get_usage_audit_logs_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for audit logs
    # Get hourly usage for audit logs.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageAuditLogsResponse, Integer, Hash)>] UsageAuditLogsResponse data, response status code and response headers
    def get_usage_audit_logs_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_audit_logs)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_audit_logs]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_audit_logs")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_audit_logs"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_audit_logs ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_audit_logs"
      end
      # resource path
      local_var_path = '/api/v1/usage/audit_logs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageAuditLogsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_audit_logs,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_audit_logs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get billable usage across your account
    # Get billable usage across your account.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage starting this month.
    # @return [UsageBillableSummaryResponse]
    def get_usage_billable_summary(opts = {})
      data, _status_code, _headers = get_usage_billable_summary_with_http_info(opts)
      data
    end

    # Get billable usage across your account
    # Get billable usage across your account.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage starting this month.
    # @return [Array<(UsageBillableSummaryResponse, Integer, Hash)>] UsageBillableSummaryResponse data, response status code and response headers
    def get_usage_billable_summary_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_billable_summary)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_billable_summary]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_billable_summary")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_billable_summary"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_billable_summary ...'
      end
      # resource path
      local_var_path = '/api/v1/usage/billable-summary'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'month'] = opts[:'month'] if !opts[:'month'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageBillableSummaryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_billable_summary,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_billable_summary\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for CI Visibility
    # Get hourly usage for CI Visibility (Tests, Pipeline, Combo, and Spans).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageCIVisibilityResponse]
    def get_usage_ci_app(start_hr, opts = {})
      data, _status_code, _headers = get_usage_ci_app_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for CI Visibility
    # Get hourly usage for CI Visibility (Tests, Pipeline, Combo, and Spans).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageCIVisibilityResponse, Integer, Hash)>] UsageCIVisibilityResponse data, response status code and response headers
    def get_usage_ci_app_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_ci_app)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_ci_app]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_ci_app")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_ci_app"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_ci_app ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_ci_app"
      end
      # resource path
      local_var_path = '/api/v1/usage/ci-app'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageCIVisibilityResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_ci_app,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_ci_app\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for CSPM
    # Get hourly usage for Cloud Security Posture Management (CSPM).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageCloudSecurityPostureManagementResponse]
    def get_usage_cloud_security_posture_management(start_hr, opts = {})
      data, _status_code, _headers = get_usage_cloud_security_posture_management_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for CSPM
    # Get hourly usage for Cloud Security Posture Management (CSPM).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageCloudSecurityPostureManagementResponse, Integer, Hash)>] UsageCloudSecurityPostureManagementResponse data, response status code and response headers
    def get_usage_cloud_security_posture_management_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_cloud_security_posture_management)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_cloud_security_posture_management]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_cloud_security_posture_management")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_cloud_security_posture_management"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_cloud_security_posture_management ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_cloud_security_posture_management"
      end
      # resource path
      local_var_path = '/api/v1/usage/cspm'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageCloudSecurityPostureManagementResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_cloud_security_posture_management,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_cloud_security_posture_management\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Cloud Workload Security
    # Get hourly usage for Cloud Workload Security.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageCWSResponse]
    def get_usage_cws(start_hr, opts = {})
      data, _status_code, _headers = get_usage_cws_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Cloud Workload Security
    # Get hourly usage for Cloud Workload Security.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageCWSResponse, Integer, Hash)>] UsageCWSResponse data, response status code and response headers
    def get_usage_cws_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_cws)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_cws]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_cws")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_cws"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_cws ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_cws"
      end
      # resource path
      local_var_path = '/api/v1/usage/cws'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageCWSResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_cws,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_cws\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Database Monitoring
    # Get hourly usage for Database Monitoring
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageDBMResponse]
    def get_usage_dbm(start_hr, opts = {})
      data, _status_code, _headers = get_usage_dbm_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Database Monitoring
    # Get hourly usage for Database Monitoring
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageDBMResponse, Integer, Hash)>] UsageDBMResponse data, response status code and response headers
    def get_usage_dbm_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_dbm)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_dbm]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_dbm")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_dbm"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_dbm ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_dbm"
      end
      # resource path
      local_var_path = '/api/v1/usage/dbm'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageDBMResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_dbm,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_dbm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Fargate
    # Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageFargateResponse]
    def get_usage_fargate(start_hr, opts = {})
      data, _status_code, _headers = get_usage_fargate_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Fargate
    # Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageFargateResponse, Integer, Hash)>] UsageFargateResponse data, response status code and response headers
    def get_usage_fargate_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_fargate)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_fargate]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_fargate")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_fargate"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_fargate ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_fargate"
      end
      # resource path
      local_var_path = '/api/v1/usage/fargate'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageFargateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_fargate,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_fargate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for hosts and containers
    # Get hourly usage for hosts and containers.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageHostsResponse]
    def get_usage_hosts(start_hr, opts = {})
      data, _status_code, _headers = get_usage_hosts_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for hosts and containers
    # Get hourly usage for hosts and containers.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageHostsResponse, Integer, Hash)>] UsageHostsResponse data, response status code and response headers
    def get_usage_hosts_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_hosts)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_hosts]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_hosts")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_hosts"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_hosts ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_hosts"
      end
      # resource path
      local_var_path = '/api/v1/usage/hosts'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageHostsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_hosts,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_hosts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for indexed spans
    # Get hourly usage for indexed spans.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageIndexedSpansResponse]
    def get_usage_indexed_spans(start_hr, opts = {})
      data, _status_code, _headers = get_usage_indexed_spans_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for indexed spans
    # Get hourly usage for indexed spans.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageIndexedSpansResponse, Integer, Hash)>] UsageIndexedSpansResponse data, response status code and response headers
    def get_usage_indexed_spans_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_indexed_spans)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_indexed_spans]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_indexed_spans")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_indexed_spans"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_indexed_spans ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_indexed_spans"
      end
      # resource path
      local_var_path = '/api/v1/usage/indexed-spans'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageIndexedSpansResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_indexed_spans,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_indexed_spans\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for IoT
    # Get hourly usage for IoT.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageIoTResponse]
    def get_usage_internet_of_things(start_hr, opts = {})
      data, _status_code, _headers = get_usage_internet_of_things_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for IoT
    # Get hourly usage for IoT.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageIoTResponse, Integer, Hash)>] UsageIoTResponse data, response status code and response headers
    def get_usage_internet_of_things_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_internet_of_things)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_internet_of_things]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_internet_of_things")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_internet_of_things"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_internet_of_things ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_internet_of_things"
      end
      # resource path
      local_var_path = '/api/v1/usage/iot'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageIoTResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_internet_of_things,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_internet_of_things\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Lambda
    # Get hourly usage for lambda.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageLambdaResponse]
    def get_usage_lambda(start_hr, opts = {})
      data, _status_code, _headers = get_usage_lambda_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Lambda
    # Get hourly usage for lambda.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageLambdaResponse, Integer, Hash)>] UsageLambdaResponse data, response status code and response headers
    def get_usage_lambda_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_lambda)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_lambda]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_lambda")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_lambda"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_lambda ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_lambda"
      end
      # resource path
      local_var_path = '/api/v1/usage/aws_lambda'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageLambdaResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_lambda,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_lambda\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Logs
    # Get hourly usage for logs.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageLogsResponse]
    def get_usage_logs(start_hr, opts = {})
      data, _status_code, _headers = get_usage_logs_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Logs
    # Get hourly usage for logs.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageLogsResponse, Integer, Hash)>] UsageLogsResponse data, response status code and response headers
    def get_usage_logs_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_logs)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_logs]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_logs")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_logs"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_logs ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_logs"
      end
      # resource path
      local_var_path = '/api/v1/usage/logs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageLogsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_logs,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_logs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Logs by Index
    # Get hourly usage for logs by index.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @option opts [Array<String>] :index_name Comma-separated list of log index names.
    # @return [UsageLogsByIndexResponse]
    def get_usage_logs_by_index(start_hr, opts = {})
      data, _status_code, _headers = get_usage_logs_by_index_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Logs by Index
    # Get hourly usage for logs by index.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @option opts [Array<String>] :index_name Comma-separated list of log index names.
    # @return [Array<(UsageLogsByIndexResponse, Integer, Hash)>] UsageLogsByIndexResponse data, response status code and response headers
    def get_usage_logs_by_index_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_logs_by_index)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_logs_by_index]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_logs_by_index")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_logs_by_index"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_logs_by_index ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_logs_by_index"
      end
      # resource path
      local_var_path = '/api/v1/usage/logs_by_index'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?
      query_params[:'index_name'] = @api_client.build_collection_param(opts[:'index_name'], :multi) if !opts[:'index_name'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageLogsByIndexResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_logs_by_index,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_logs_by_index\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly logs usage by retention
    # Get hourly usage for indexed logs by retention period.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageLogsByRetentionResponse]
    def get_usage_logs_by_retention(start_hr, opts = {})
      data, _status_code, _headers = get_usage_logs_by_retention_with_http_info(start_hr, opts)
      data
    end

    # Get hourly logs usage by retention
    # Get hourly usage for indexed logs by retention period.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageLogsByRetentionResponse, Integer, Hash)>] UsageLogsByRetentionResponse data, response status code and response headers
    def get_usage_logs_by_retention_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_logs_by_retention)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_logs_by_retention]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_logs_by_retention")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_logs_by_retention"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_logs_by_retention ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_logs_by_retention"
      end
      # resource path
      local_var_path = '/api/v1/usage/logs-by-retention'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageLogsByRetentionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_logs_by_retention,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_logs_by_retention\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Network Flows
    # Get hourly usage for network flows.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageNetworkFlowsResponse]
    def get_usage_network_flows(start_hr, opts = {})
      data, _status_code, _headers = get_usage_network_flows_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Network Flows
    # Get hourly usage for network flows.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageNetworkFlowsResponse, Integer, Hash)>] UsageNetworkFlowsResponse data, response status code and response headers
    def get_usage_network_flows_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_network_flows)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_network_flows]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_network_flows")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_network_flows"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_network_flows ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_network_flows"
      end
      # resource path
      local_var_path = '/api/v1/usage/network_flows'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageNetworkFlowsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_network_flows,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_network_flows\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Network Hosts
    # Get hourly usage for network hosts.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageNetworkHostsResponse]
    def get_usage_network_hosts(start_hr, opts = {})
      data, _status_code, _headers = get_usage_network_hosts_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Network Hosts
    # Get hourly usage for network hosts.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageNetworkHostsResponse, Integer, Hash)>] UsageNetworkHostsResponse data, response status code and response headers
    def get_usage_network_hosts_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_network_hosts)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_network_hosts]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_network_hosts")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_network_hosts"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_network_hosts ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_network_hosts"
      end
      # resource path
      local_var_path = '/api/v1/usage/network_hosts'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageNetworkHostsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_network_hosts,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_network_hosts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for profiled hosts
    # Get hourly usage for profiled hosts.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageProfilingResponse]
    def get_usage_profiling(start_hr, opts = {})
      data, _status_code, _headers = get_usage_profiling_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for profiled hosts
    # Get hourly usage for profiled hosts.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageProfilingResponse, Integer, Hash)>] UsageProfilingResponse data, response status code and response headers
    def get_usage_profiling_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_profiling)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_profiling]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_profiling")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_profiling"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_profiling ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_profiling"
      end
      # resource path
      local_var_path = '/api/v1/usage/profiling'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageProfilingResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_profiling,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_profiling\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for RUM Sessions
    # Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @option opts [String] :type RUM type: `[browser, mobile]`. Defaults to `browser`.
    # @return [UsageRumSessionsResponse]
    def get_usage_rum_sessions(start_hr, opts = {})
      data, _status_code, _headers = get_usage_rum_sessions_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for RUM Sessions
    # Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @option opts [String] :type RUM type: `[browser, mobile]`. Defaults to `browser`.
    # @return [Array<(UsageRumSessionsResponse, Integer, Hash)>] UsageRumSessionsResponse data, response status code and response headers
    def get_usage_rum_sessions_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_rum_sessions)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_rum_sessions]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_rum_sessions")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_rum_sessions"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_rum_sessions ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_rum_sessions"
      end
      # resource path
      local_var_path = '/api/v1/usage/rum_sessions'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageRumSessionsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_rum_sessions,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_rum_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for RUM Units
    # Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Units.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageRumUnitsResponse]
    def get_usage_rum_units(start_hr, opts = {})
      data, _status_code, _headers = get_usage_rum_units_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for RUM Units
    # Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Units.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageRumUnitsResponse, Integer, Hash)>] UsageRumUnitsResponse data, response status code and response headers
    def get_usage_rum_units_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_rum_units)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_rum_units]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_rum_units")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_rum_units"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_rum_units ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_rum_units"
      end
      # resource path
      local_var_path = '/api/v1/usage/rum'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageRumUnitsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_rum_units,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_rum_units\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Sensitive Data Scanner
    # Get hourly usage for Sensitive Data Scanner.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageSDSResponse]
    def get_usage_sds(start_hr, opts = {})
      data, _status_code, _headers = get_usage_sds_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Sensitive Data Scanner
    # Get hourly usage for Sensitive Data Scanner.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageSDSResponse, Integer, Hash)>] UsageSDSResponse data, response status code and response headers
    def get_usage_sds_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_sds)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_sds]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_sds")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_sds"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_sds ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_sds"
      end
      # resource path
      local_var_path = '/api/v1/usage/sds'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSDSResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_sds,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_sds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for SNMP devices
    # Get hourly usage for SNMP devices.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [UsageSNMPResponse]
    def get_usage_snmp(start_hr, opts = {})
      data, _status_code, _headers = get_usage_snmp_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for SNMP devices
    # Get hourly usage for SNMP devices.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: `[YYYY-MM-DDThh]` for usage ending **before** this hour.
    # @return [Array<(UsageSNMPResponse, Integer, Hash)>] UsageSNMPResponse data, response status code and response headers
    def get_usage_snmp_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_snmp)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_snmp]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_snmp")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_snmp"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_snmp ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_snmp"
      end
      # resource path
      local_var_path = '/api/v1/usage/snmp'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSNMPResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_snmp,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_snmp\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get usage across your multi-org account
    # Get usage across your multi-org account. You must have the multi-org feature enabled.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [Boolean] :include_org_details Include usage summaries for each sub-org.
    # @return [UsageSummaryResponse]
    def get_usage_summary(start_month, opts = {})
      data, _status_code, _headers = get_usage_summary_with_http_info(start_month, opts)
      data
    end

    # Get usage across your multi-org account
    # Get usage across your multi-org account. You must have the multi-org feature enabled.
    # @param start_month [Time] Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage beginning in this month. Maximum of 15 months ago.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_month Datetime in ISO-8601 format, UTC, precise to month: `[YYYY-MM]` for usage ending this month.
    # @option opts [Boolean] :include_org_details Include usage summaries for each sub-org.
    # @return [Array<(UsageSummaryResponse, Integer, Hash)>] UsageSummaryResponse data, response status code and response headers
    def get_usage_summary_with_http_info(start_month, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_summary)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_summary]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_summary")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_summary"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_summary ...'
      end
      # verify the required parameter 'start_month' is set
      if @api_client.config.client_side_validation && start_month.nil?
        fail ArgumentError, "Missing the required parameter 'start_month' when calling UsageMeteringAPI.get_usage_summary"
      end
      # resource path
      local_var_path = '/api/v1/usage/summary'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_month'] = start_month
      query_params[:'end_month'] = opts[:'end_month'] if !opts[:'end_month'].nil?
      query_params[:'include_org_details'] = opts[:'include_org_details'] if !opts[:'include_org_details'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSummaryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_summary,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_summary\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Synthetics Checks
    # Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageSyntheticsResponse]
    def get_usage_synthetics(start_hr, opts = {})
      data, _status_code, _headers = get_usage_synthetics_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Synthetics Checks
    # Get hourly usage for [Synthetics checks](https://docs.datadoghq.com/synthetics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageSyntheticsResponse, Integer, Hash)>] UsageSyntheticsResponse data, response status code and response headers
    def get_usage_synthetics_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_synthetics)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_synthetics]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_synthetics")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_synthetics"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_synthetics ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_synthetics"
      end
      # resource path
      local_var_path = '/api/v1/usage/synthetics'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSyntheticsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_synthetics,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_synthetics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Synthetics API Checks
    # Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageSyntheticsAPIResponse]
    def get_usage_synthetics_api(start_hr, opts = {})
      data, _status_code, _headers = get_usage_synthetics_api_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Synthetics API Checks
    # Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageSyntheticsAPIResponse, Integer, Hash)>] UsageSyntheticsAPIResponse data, response status code and response headers
    def get_usage_synthetics_api_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_synthetics_api)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_synthetics_api]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_synthetics_api")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_synthetics_api"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_synthetics_api ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_synthetics_api"
      end
      # resource path
      local_var_path = '/api/v1/usage/synthetics_api'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSyntheticsAPIResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_synthetics_api,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_synthetics_api\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for Synthetics Browser Checks
    # Get hourly usage for synthetics browser checks.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageSyntheticsBrowserResponse]
    def get_usage_synthetics_browser(start_hr, opts = {})
      data, _status_code, _headers = get_usage_synthetics_browser_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for Synthetics Browser Checks
    # Get hourly usage for synthetics browser checks.
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageSyntheticsBrowserResponse, Integer, Hash)>] UsageSyntheticsBrowserResponse data, response status code and response headers
    def get_usage_synthetics_browser_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_synthetics_browser)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_synthetics_browser]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_synthetics_browser")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_synthetics_browser"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_synthetics_browser ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_synthetics_browser"
      end
      # resource path
      local_var_path = '/api/v1/usage/synthetics_browser'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageSyntheticsBrowserResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_synthetics_browser,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_synthetics_browser\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get hourly usage for custom metrics
    # Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [UsageTimeseriesResponse]
    def get_usage_timeseries(start_hr, opts = {})
      data, _status_code, _headers = get_usage_timeseries_with_http_info(start_hr, opts)
      data
    end

    # Get hourly usage for custom metrics
    # Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
    # @param start_hr [Time] Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage beginning at this hour.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :end_hr Datetime in ISO-8601 format, UTC, precise to hour: [YYYY-MM-DDThh] for usage ending **before** this hour.
    # @return [Array<(UsageTimeseriesResponse, Integer, Hash)>] UsageTimeseriesResponse data, response status code and response headers
    def get_usage_timeseries_with_http_info(start_hr, opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_timeseries)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_timeseries]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_timeseries")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_timeseries"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_timeseries ...'
      end
      # verify the required parameter 'start_hr' is set
      if @api_client.config.client_side_validation && start_hr.nil?
        fail ArgumentError, "Missing the required parameter 'start_hr' when calling UsageMeteringAPI.get_usage_timeseries"
      end
      # resource path
      local_var_path = '/api/v1/usage/timeseries'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'start_hr'] = start_hr
      query_params[:'end_hr'] = opts[:'end_hr'] if !opts[:'end_hr'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageTimeseriesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_timeseries,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_timeseries\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all custom metrics by hourly average
    # Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :month Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM] for usage beginning at this hour. (Either month or day should be specified, but not both)
    # @option opts [Time] :day Datetime in ISO-8601 format, UTC, precise to day: [YYYY-MM-DD] for usage beginning at this hour. (Either month or day should be specified, but not both)
    # @option opts [Array<String>] :names Comma-separated list of metric names.
    # @option opts [Integer] :limit Maximum number of results to return (between 1 and 5000) - defaults to 500 results if limit not specified.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @return [UsageTopAvgMetricsResponse]
    def get_usage_top_avg_metrics(opts = {})
      data, _status_code, _headers = get_usage_top_avg_metrics_with_http_info(opts)
      data
    end

    # Get all custom metrics by hourly average
    # Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
    # @param opts [Hash] the optional parameters
    # @option opts [Time] :month Datetime in ISO-8601 format, UTC, precise to month: [YYYY-MM] for usage beginning at this hour. (Either month or day should be specified, but not both)
    # @option opts [Time] :day Datetime in ISO-8601 format, UTC, precise to day: [YYYY-MM-DD] for usage beginning at this hour. (Either month or day should be specified, but not both)
    # @option opts [Array<String>] :names Comma-separated list of metric names.
    # @option opts [Integer] :limit Maximum number of results to return (between 1 and 5000) - defaults to 500 results if limit not specified.
    # @option opts [String] :next_record_id List following results with a next_record_id provided in the previous query.
    # @return [Array<(UsageTopAvgMetricsResponse, Integer, Hash)>] UsageTopAvgMetricsResponse data, response status code and response headers
    def get_usage_top_avg_metrics_with_http_info(opts = {})

      if @api_client.config.unstable_operations.has_key?(:get_usage_top_avg_metrics)
        unstable_enabled = @api_client.config.unstable_operations[:get_usage_top_avg_metrics]
        if unstable_enabled
          @api_client.config.logger.warn format("Using unstable operation '%s'", "get_usage_top_avg_metrics")
        else
          raise APIError.new(message: format("Unstable operation '%s' is disabled", "get_usage_top_avg_metrics"))
        end
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsageMeteringAPI.get_usage_top_avg_metrics ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 5000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsageMeteringAPI.get_usage_top_avg_metrics, must be smaller than or equal to 5000.'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsageMeteringAPI.get_usage_top_avg_metrics, must be greater than or equal to 1.'
      end
      # resource path
      local_var_path = '/api/v1/usage/top_avg_metrics'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'month'] = opts[:'month'] if !opts[:'month'].nil?
      query_params[:'day'] = opts[:'day'] if !opts[:'day'].nil?
      query_params[:'names'] = @api_client.build_collection_param(opts[:'names'], :multi) if !opts[:'names'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'next_record_id'] = opts[:'next_record_id'] if !opts[:'next_record_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json;datetime-format=rfc3339'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UsageTopAvgMetricsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_usage_top_avg_metrics,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsageMeteringAPI#get_usage_top_avg_metrics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
