=begin
#Datadog API V1 Collection

#Collection of all Datadog Public endpoints.

The version of the OpenAPI document: 1.0
Contact: support@datadoghq.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.0.0-SNAPSHOT

=end

require 'date'

module DatadogAPIClient::V1
  # [Definition of the widget](https://docs.datadoghq.com/dashboards/widgets/).
  class WidgetDefinition
    # ID of the alert to use in the widget.
    attr_accessor :alert_id

    attr_accessor :time

    # Title of your widget.
    attr_accessor :title

    attr_accessor :title_align

    # Size of the title.
    attr_accessor :title_size

    attr_accessor :type

    attr_accessor :viz_type

    # Number of decimals to show. If not defined, the widget uses the raw value.
    attr_accessor :precision

    attr_accessor :text_align

    # Unit to display with the value.
    attr_accessor :unit

    # List of custom links.
    attr_accessor :custom_links

    # List of top list widget requests.
    attr_accessor :requests

    # Name of the check to use in the widget.
    attr_accessor :check

    # List of tag prefixes to group by.
    attr_accessor :group

    # List of tag prefixes to group by in the case of a cluster check.
    attr_accessor :group_by

    attr_accessor :grouping

    # List of tags used to filter the groups reporting a cluster check.
    attr_accessor :tags

    # Available legend sizes for a widget. Should be one of \"0\", \"2\", \"4\", \"8\", \"16\", or \"auto\".
    attr_accessor :legend_size

    # (screenboard only) Show the legend for this widget.
    attr_accessor :show_legend

    attr_accessor :event_size

    # Query to filter the monitors with.
    attr_accessor :query

    # The execution method for multi-value filters. Can be either and or or.
    attr_accessor :tags_execution

    # Color of the text.
    attr_accessor :color

    # Size of the text.
    attr_accessor :font_size

    # Text to display.
    attr_accessor :text

    attr_accessor :layout_type

    # List of widget groups.
    attr_accessor :widgets

    # List of widget events.
    attr_accessor :events

    attr_accessor :yaxis

    # Whether to show the hosts that donâ€™t fit in a group.
    attr_accessor :no_group_hosts

    # Whether to show the hosts with no metrics.
    attr_accessor :no_metric_hosts

    attr_accessor :node_type

    # Notes on the title.
    attr_accessor :notes

    # List of tags used to filter the map.
    attr_accessor :scope

    attr_accessor :style

    # URL of the image.
    attr_accessor :url

    attr_accessor :margin

    attr_accessor :sizing

    # Which columns to display on the widget.
    attr_accessor :columns

    # An array of index names to query in the stream. Use [] to query all indexes at once.
    attr_accessor :indexes

    # ID of the log set to use.
    attr_accessor :logset

    attr_accessor :message_display

    # Whether to show the date column or not
    attr_accessor :show_date_column

    # Whether to show the message column or not
    attr_accessor :show_message_column

    attr_accessor :sort

    attr_accessor :color_preference

    # The number of monitors to display.
    attr_accessor :count

    attr_accessor :display_format

    # Whether to show counts of 0 or not.
    attr_accessor :hide_zero_counts

    # Whether to show the time that has elapsed since the monitor/group triggered.
    attr_accessor :show_last_triggered

    # The start of the list. Typically 0.
    attr_accessor :start

    attr_accessor :summary_type

    # Background color of the note.
    attr_accessor :background_color

    # Content of the note.
    attr_accessor :content

    # Whether to show a tick or not.
    attr_accessor :show_tick

    attr_accessor :tick_edge

    # Where to position the tick on an edge.
    attr_accessor :tick_pos

    # Whether to use auto-scaling or not.
    attr_accessor :autoscale

    # Display a unit of your choice on the widget.
    attr_accessor :custom_unit

    # List of groups used for colors.
    attr_accessor :color_by_groups

    attr_accessor :xaxis

    # Defined error budget.
    attr_accessor :show_error_budget

    # ID of the SLO displayed.
    attr_accessor :slo_id

    # Times being monitored.
    attr_accessor :time_windows

    attr_accessor :view_mode

    # Type of view displayed by the widget.
    attr_accessor :view_type

    # Your environment and primary tag (or * if enabled for your account).
    attr_accessor :filters

    # APM service.
    attr_accessor :service

    # APM environment.
    attr_accessor :env

    # Whether to show the latency breakdown or not.
    attr_accessor :show_breakdown

    # Whether to show the latency distribution or not.
    attr_accessor :show_distribution

    # Whether to show the error metrics or not.
    attr_accessor :show_errors

    # Whether to show the hits metrics or not.
    attr_accessor :show_hits

    # Whether to show the latency metrics or not.
    attr_accessor :show_latency

    # Whether to show the resource list or not.
    attr_accessor :show_resource_list

    attr_accessor :size_format

    # APM span name.
    attr_accessor :span_name

    # List of markers.
    attr_accessor :markers

    attr_accessor :right_yaxis

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'alert_id' => :'alert_id',
        :'time' => :'time',
        :'title' => :'title',
        :'title_align' => :'title_align',
        :'title_size' => :'title_size',
        :'type' => :'type',
        :'viz_type' => :'viz_type',
        :'precision' => :'precision',
        :'text_align' => :'text_align',
        :'unit' => :'unit',
        :'custom_links' => :'custom_links',
        :'requests' => :'requests',
        :'check' => :'check',
        :'group' => :'group',
        :'group_by' => :'group_by',
        :'grouping' => :'grouping',
        :'tags' => :'tags',
        :'legend_size' => :'legend_size',
        :'show_legend' => :'show_legend',
        :'event_size' => :'event_size',
        :'query' => :'query',
        :'tags_execution' => :'tags_execution',
        :'color' => :'color',
        :'font_size' => :'font_size',
        :'text' => :'text',
        :'layout_type' => :'layout_type',
        :'widgets' => :'widgets',
        :'events' => :'events',
        :'yaxis' => :'yaxis',
        :'no_group_hosts' => :'no_group_hosts',
        :'no_metric_hosts' => :'no_metric_hosts',
        :'node_type' => :'node_type',
        :'notes' => :'notes',
        :'scope' => :'scope',
        :'style' => :'style',
        :'url' => :'url',
        :'margin' => :'margin',
        :'sizing' => :'sizing',
        :'columns' => :'columns',
        :'indexes' => :'indexes',
        :'logset' => :'logset',
        :'message_display' => :'message_display',
        :'show_date_column' => :'show_date_column',
        :'show_message_column' => :'show_message_column',
        :'sort' => :'sort',
        :'color_preference' => :'color_preference',
        :'count' => :'count',
        :'display_format' => :'display_format',
        :'hide_zero_counts' => :'hide_zero_counts',
        :'show_last_triggered' => :'show_last_triggered',
        :'start' => :'start',
        :'summary_type' => :'summary_type',
        :'background_color' => :'background_color',
        :'content' => :'content',
        :'show_tick' => :'show_tick',
        :'tick_edge' => :'tick_edge',
        :'tick_pos' => :'tick_pos',
        :'autoscale' => :'autoscale',
        :'custom_unit' => :'custom_unit',
        :'color_by_groups' => :'color_by_groups',
        :'xaxis' => :'xaxis',
        :'show_error_budget' => :'show_error_budget',
        :'slo_id' => :'slo_id',
        :'time_windows' => :'time_windows',
        :'view_mode' => :'view_mode',
        :'view_type' => :'view_type',
        :'filters' => :'filters',
        :'service' => :'service',
        :'env' => :'env',
        :'show_breakdown' => :'show_breakdown',
        :'show_distribution' => :'show_distribution',
        :'show_errors' => :'show_errors',
        :'show_hits' => :'show_hits',
        :'show_latency' => :'show_latency',
        :'show_resource_list' => :'show_resource_list',
        :'size_format' => :'size_format',
        :'span_name' => :'span_name',
        :'markers' => :'markers',
        :'right_yaxis' => :'right_yaxis'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'alert_id' => :'String',
        :'time' => :'WidgetTime',
        :'title' => :'String',
        :'title_align' => :'WidgetTextAlign',
        :'title_size' => :'String',
        :'type' => :'ToplistWidgetDefinitionType',
        :'viz_type' => :'WidgetVizType',
        :'precision' => :'Integer',
        :'text_align' => :'WidgetTextAlign',
        :'unit' => :'String',
        :'custom_links' => :'Array<WidgetCustomLink>',
        :'requests' => :'Array<ToplistWidgetRequest>',
        :'check' => :'String',
        :'group' => :'Array<String>',
        :'group_by' => :'Array<String>',
        :'grouping' => :'WidgetGrouping',
        :'tags' => :'Array<String>',
        :'legend_size' => :'String',
        :'show_legend' => :'Boolean',
        :'event_size' => :'WidgetEventSize',
        :'query' => :'String',
        :'tags_execution' => :'String',
        :'color' => :'String',
        :'font_size' => :'String',
        :'text' => :'String',
        :'layout_type' => :'WidgetLayoutType',
        :'widgets' => :'Array<Widget>',
        :'events' => :'Array<WidgetEvent>',
        :'yaxis' => :'WidgetAxis',
        :'no_group_hosts' => :'Boolean',
        :'no_metric_hosts' => :'Boolean',
        :'node_type' => :'WidgetNodeType',
        :'notes' => :'String',
        :'scope' => :'Array<String>',
        :'style' => :'HostMapWidgetDefinitionStyle',
        :'url' => :'String',
        :'margin' => :'WidgetMargin',
        :'sizing' => :'WidgetImageSizing',
        :'columns' => :'Array<String>',
        :'indexes' => :'Array<String>',
        :'logset' => :'String',
        :'message_display' => :'WidgetMessageDisplay',
        :'show_date_column' => :'Boolean',
        :'show_message_column' => :'Boolean',
        :'sort' => :'WidgetMonitorSummarySort',
        :'color_preference' => :'WidgetColorPreference',
        :'count' => :'Integer',
        :'display_format' => :'WidgetServiceSummaryDisplayFormat',
        :'hide_zero_counts' => :'Boolean',
        :'show_last_triggered' => :'Boolean',
        :'start' => :'Integer',
        :'summary_type' => :'WidgetSummaryType',
        :'background_color' => :'String',
        :'content' => :'String',
        :'show_tick' => :'Boolean',
        :'tick_edge' => :'WidgetTickEdge',
        :'tick_pos' => :'String',
        :'autoscale' => :'Boolean',
        :'custom_unit' => :'String',
        :'color_by_groups' => :'Array<String>',
        :'xaxis' => :'WidgetAxis',
        :'show_error_budget' => :'Boolean',
        :'slo_id' => :'String',
        :'time_windows' => :'Array<WidgetTimeWindows>',
        :'view_mode' => :'WidgetViewMode',
        :'view_type' => :'String',
        :'filters' => :'Array<String>',
        :'service' => :'String',
        :'env' => :'String',
        :'show_breakdown' => :'Boolean',
        :'show_distribution' => :'Boolean',
        :'show_errors' => :'Boolean',
        :'show_hits' => :'Boolean',
        :'show_latency' => :'Boolean',
        :'show_resource_list' => :'Boolean',
        :'size_format' => :'WidgetSizeFormat',
        :'span_name' => :'String',
        :'markers' => :'Array<WidgetMarker>',
        :'right_yaxis' => :'WidgetAxis'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # List of class defined in oneOf (OpenAPI v3)
    def self.openapi_one_of
      [
      :'AlertGraphWidgetDefinition',
      :'AlertValueWidgetDefinition',
      :'ChangeWidgetDefinition',
      :'CheckStatusWidgetDefinition',
      :'DistributionWidgetDefinition',
      :'EventStreamWidgetDefinition',
      :'EventTimelineWidgetDefinition',
      :'FreeTextWidgetDefinition',
      :'GroupWidgetDefinition',
      :'HeatMapWidgetDefinition',
      :'HostMapWidgetDefinition',
      :'IFrameWidgetDefinition',
      :'ImageWidgetDefinition',
      :'LogStreamWidgetDefinition',
      :'MonitorSummaryWidgetDefinition',
      :'NoteWidgetDefinition',
      :'QueryValueWidgetDefinition',
      :'SLOWidgetDefinition',
      :'ScatterPlotWidgetDefinition',
      :'ServiceMapWidgetDefinition',
      :'ServiceSummaryWidgetDefinition',
      :'TableWidgetDefinition',
      :'TimeseriesWidgetDefinition',
      :'ToplistWidgetDefinition'
      ]
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `DatadogAPIClient::V1::WidgetDefinition` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `DatadogAPIClient::V1::WidgetDefinition`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'alert_id')
        self.alert_id = attributes[:'alert_id']
      end

      if attributes.key?(:'time')
        self.time = attributes[:'time']
      end

      if attributes.key?(:'title')
        self.title = attributes[:'title']
      end

      if attributes.key?(:'title_align')
        self.title_align = attributes[:'title_align']
      end

      if attributes.key?(:'title_size')
        self.title_size = attributes[:'title_size']
      end

      if attributes.key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.key?(:'viz_type')
        self.viz_type = attributes[:'viz_type']
      end

      if attributes.key?(:'precision')
        self.precision = attributes[:'precision']
      end

      if attributes.key?(:'text_align')
        self.text_align = attributes[:'text_align']
      end

      if attributes.key?(:'unit')
        self.unit = attributes[:'unit']
      end

      if attributes.key?(:'custom_links')
        if (value = attributes[:'custom_links']).is_a?(Array)
          self.custom_links = value
        end
      end

      if attributes.key?(:'requests')
        if (value = attributes[:'requests']).is_a?(Array)
          self.requests = value
        end
      end

      if attributes.key?(:'check')
        self.check = attributes[:'check']
      end

      if attributes.key?(:'group')
        if (value = attributes[:'group']).is_a?(Array)
          self.group = value
        end
      end

      if attributes.key?(:'group_by')
        if (value = attributes[:'group_by']).is_a?(Array)
          self.group_by = value
        end
      end

      if attributes.key?(:'grouping')
        self.grouping = attributes[:'grouping']
      end

      if attributes.key?(:'tags')
        if (value = attributes[:'tags']).is_a?(Array)
          self.tags = value
        end
      end

      if attributes.key?(:'legend_size')
        self.legend_size = attributes[:'legend_size']
      end

      if attributes.key?(:'show_legend')
        self.show_legend = attributes[:'show_legend']
      end

      if attributes.key?(:'event_size')
        self.event_size = attributes[:'event_size']
      end

      if attributes.key?(:'query')
        self.query = attributes[:'query']
      end

      if attributes.key?(:'tags_execution')
        self.tags_execution = attributes[:'tags_execution']
      end

      if attributes.key?(:'color')
        self.color = attributes[:'color']
      end

      if attributes.key?(:'font_size')
        self.font_size = attributes[:'font_size']
      end

      if attributes.key?(:'text')
        self.text = attributes[:'text']
      end

      if attributes.key?(:'layout_type')
        self.layout_type = attributes[:'layout_type']
      end

      if attributes.key?(:'widgets')
        if (value = attributes[:'widgets']).is_a?(Array)
          self.widgets = value
        end
      end

      if attributes.key?(:'events')
        if (value = attributes[:'events']).is_a?(Array)
          self.events = value
        end
      end

      if attributes.key?(:'yaxis')
        self.yaxis = attributes[:'yaxis']
      end

      if attributes.key?(:'no_group_hosts')
        self.no_group_hosts = attributes[:'no_group_hosts']
      end

      if attributes.key?(:'no_metric_hosts')
        self.no_metric_hosts = attributes[:'no_metric_hosts']
      end

      if attributes.key?(:'node_type')
        self.node_type = attributes[:'node_type']
      end

      if attributes.key?(:'notes')
        self.notes = attributes[:'notes']
      end

      if attributes.key?(:'scope')
        if (value = attributes[:'scope']).is_a?(Array)
          self.scope = value
        end
      end

      if attributes.key?(:'style')
        self.style = attributes[:'style']
      end

      if attributes.key?(:'url')
        self.url = attributes[:'url']
      end

      if attributes.key?(:'margin')
        self.margin = attributes[:'margin']
      end

      if attributes.key?(:'sizing')
        self.sizing = attributes[:'sizing']
      end

      if attributes.key?(:'columns')
        if (value = attributes[:'columns']).is_a?(Array)
          self.columns = value
        end
      end

      if attributes.key?(:'indexes')
        if (value = attributes[:'indexes']).is_a?(Array)
          self.indexes = value
        end
      end

      if attributes.key?(:'logset')
        self.logset = attributes[:'logset']
      end

      if attributes.key?(:'message_display')
        self.message_display = attributes[:'message_display']
      end

      if attributes.key?(:'show_date_column')
        self.show_date_column = attributes[:'show_date_column']
      end

      if attributes.key?(:'show_message_column')
        self.show_message_column = attributes[:'show_message_column']
      end

      if attributes.key?(:'sort')
        self.sort = attributes[:'sort']
      end

      if attributes.key?(:'color_preference')
        self.color_preference = attributes[:'color_preference']
      end

      if attributes.key?(:'count')
        self.count = attributes[:'count']
      end

      if attributes.key?(:'display_format')
        self.display_format = attributes[:'display_format']
      end

      if attributes.key?(:'hide_zero_counts')
        self.hide_zero_counts = attributes[:'hide_zero_counts']
      end

      if attributes.key?(:'show_last_triggered')
        self.show_last_triggered = attributes[:'show_last_triggered']
      end

      if attributes.key?(:'start')
        self.start = attributes[:'start']
      end

      if attributes.key?(:'summary_type')
        self.summary_type = attributes[:'summary_type']
      end

      if attributes.key?(:'background_color')
        self.background_color = attributes[:'background_color']
      end

      if attributes.key?(:'content')
        self.content = attributes[:'content']
      end

      if attributes.key?(:'show_tick')
        self.show_tick = attributes[:'show_tick']
      end

      if attributes.key?(:'tick_edge')
        self.tick_edge = attributes[:'tick_edge']
      end

      if attributes.key?(:'tick_pos')
        self.tick_pos = attributes[:'tick_pos']
      end

      if attributes.key?(:'autoscale')
        self.autoscale = attributes[:'autoscale']
      end

      if attributes.key?(:'custom_unit')
        self.custom_unit = attributes[:'custom_unit']
      end

      if attributes.key?(:'color_by_groups')
        if (value = attributes[:'color_by_groups']).is_a?(Array)
          self.color_by_groups = value
        end
      end

      if attributes.key?(:'xaxis')
        self.xaxis = attributes[:'xaxis']
      end

      if attributes.key?(:'show_error_budget')
        self.show_error_budget = attributes[:'show_error_budget']
      end

      if attributes.key?(:'slo_id')
        self.slo_id = attributes[:'slo_id']
      end

      if attributes.key?(:'time_windows')
        if (value = attributes[:'time_windows']).is_a?(Array)
          self.time_windows = value
        end
      end

      if attributes.key?(:'view_mode')
        self.view_mode = attributes[:'view_mode']
      end

      if attributes.key?(:'view_type')
        self.view_type = attributes[:'view_type']
      else
        self.view_type = 'detail'
      end

      if attributes.key?(:'filters')
        if (value = attributes[:'filters']).is_a?(Array)
          self.filters = value
        end
      end

      if attributes.key?(:'service')
        self.service = attributes[:'service']
      end

      if attributes.key?(:'env')
        self.env = attributes[:'env']
      end

      if attributes.key?(:'show_breakdown')
        self.show_breakdown = attributes[:'show_breakdown']
      end

      if attributes.key?(:'show_distribution')
        self.show_distribution = attributes[:'show_distribution']
      end

      if attributes.key?(:'show_errors')
        self.show_errors = attributes[:'show_errors']
      end

      if attributes.key?(:'show_hits')
        self.show_hits = attributes[:'show_hits']
      end

      if attributes.key?(:'show_latency')
        self.show_latency = attributes[:'show_latency']
      end

      if attributes.key?(:'show_resource_list')
        self.show_resource_list = attributes[:'show_resource_list']
      end

      if attributes.key?(:'size_format')
        self.size_format = attributes[:'size_format']
      end

      if attributes.key?(:'span_name')
        self.span_name = attributes[:'span_name']
      end

      if attributes.key?(:'markers')
        if (value = attributes[:'markers']).is_a?(Array)
          self.markers = value
        end
      end

      if attributes.key?(:'right_yaxis')
        self.right_yaxis = attributes[:'right_yaxis']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @alert_id.nil?
        invalid_properties.push('invalid value for "alert_id", alert_id cannot be nil.')
      end

      if @type.nil?
        invalid_properties.push('invalid value for "type", type cannot be nil.')
      end

      if @viz_type.nil?
        invalid_properties.push('invalid value for "viz_type", viz_type cannot be nil.')
      end

      if @requests.nil?
        invalid_properties.push('invalid value for "requests", requests cannot be nil.')
      end

      if @check.nil?
        invalid_properties.push('invalid value for "check", check cannot be nil.')
      end

      if @grouping.nil?
        invalid_properties.push('invalid value for "grouping", grouping cannot be nil.')
      end

      if @query.nil?
        invalid_properties.push('invalid value for "query", query cannot be nil.')
      end

      if @text.nil?
        invalid_properties.push('invalid value for "text", text cannot be nil.')
      end

      if @layout_type.nil?
        invalid_properties.push('invalid value for "layout_type", layout_type cannot be nil.')
      end

      if @widgets.nil?
        invalid_properties.push('invalid value for "widgets", widgets cannot be nil.')
      end

      if @url.nil?
        invalid_properties.push('invalid value for "url", url cannot be nil.')
      end

      if @content.nil?
        invalid_properties.push('invalid value for "content", content cannot be nil.')
      end

      if @view_type.nil?
        invalid_properties.push('invalid value for "view_type", view_type cannot be nil.')
      end

      if @filters.nil?
        invalid_properties.push('invalid value for "filters", filters cannot be nil.')
      end

      if @service.nil?
        invalid_properties.push('invalid value for "service", service cannot be nil.')
      end

      if @env.nil?
        invalid_properties.push('invalid value for "env", env cannot be nil.')
      end

      if @span_name.nil?
        invalid_properties.push('invalid value for "span_name", span_name cannot be nil.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @alert_id.nil?
      return false if @type.nil?
      return false if @viz_type.nil?
      return false if @requests.nil?
      return false if @check.nil?
      return false if @grouping.nil?
      return false if @query.nil?
      return false if @text.nil?
      return false if @layout_type.nil?
      return false if @widgets.nil?
      return false if @url.nil?
      return false if @content.nil?
      return false if @view_type.nil?
      return false if @filters.nil?
      return false if @service.nil?
      return false if @env.nil?
      return false if @span_name.nil?
      _one_of_found = false
      self.class.openapi_one_of.each do |_class|
        _one_of = DatadogAPIClient::V1.const_get(_class).build_from_hash(self.to_hash)
        if _one_of.valid?
          if _one_of_found
            return false
          else
            _one_of_found = true
          end
        end
      end

      if !_one_of_found
        return false
      end

      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          alert_id == o.alert_id &&
          time == o.time &&
          title == o.title &&
          title_align == o.title_align &&
          title_size == o.title_size &&
          type == o.type &&
          viz_type == o.viz_type &&
          precision == o.precision &&
          text_align == o.text_align &&
          unit == o.unit &&
          custom_links == o.custom_links &&
          requests == o.requests &&
          check == o.check &&
          group == o.group &&
          group_by == o.group_by &&
          grouping == o.grouping &&
          tags == o.tags &&
          legend_size == o.legend_size &&
          show_legend == o.show_legend &&
          event_size == o.event_size &&
          query == o.query &&
          tags_execution == o.tags_execution &&
          color == o.color &&
          font_size == o.font_size &&
          text == o.text &&
          layout_type == o.layout_type &&
          widgets == o.widgets &&
          events == o.events &&
          yaxis == o.yaxis &&
          no_group_hosts == o.no_group_hosts &&
          no_metric_hosts == o.no_metric_hosts &&
          node_type == o.node_type &&
          notes == o.notes &&
          scope == o.scope &&
          style == o.style &&
          url == o.url &&
          margin == o.margin &&
          sizing == o.sizing &&
          columns == o.columns &&
          indexes == o.indexes &&
          logset == o.logset &&
          message_display == o.message_display &&
          show_date_column == o.show_date_column &&
          show_message_column == o.show_message_column &&
          sort == o.sort &&
          color_preference == o.color_preference &&
          count == o.count &&
          display_format == o.display_format &&
          hide_zero_counts == o.hide_zero_counts &&
          show_last_triggered == o.show_last_triggered &&
          start == o.start &&
          summary_type == o.summary_type &&
          background_color == o.background_color &&
          content == o.content &&
          show_tick == o.show_tick &&
          tick_edge == o.tick_edge &&
          tick_pos == o.tick_pos &&
          autoscale == o.autoscale &&
          custom_unit == o.custom_unit &&
          color_by_groups == o.color_by_groups &&
          xaxis == o.xaxis &&
          show_error_budget == o.show_error_budget &&
          slo_id == o.slo_id &&
          time_windows == o.time_windows &&
          view_mode == o.view_mode &&
          view_type == o.view_type &&
          filters == o.filters &&
          service == o.service &&
          env == o.env &&
          show_breakdown == o.show_breakdown &&
          show_distribution == o.show_distribution &&
          show_errors == o.show_errors &&
          show_hits == o.show_hits &&
          show_latency == o.show_latency &&
          show_resource_list == o.show_resource_list &&
          size_format == o.size_format &&
          span_name == o.span_name &&
          markers == o.markers &&
          right_yaxis == o.right_yaxis
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [alert_id, time, title, title_align, title_size, type, viz_type, precision, text_align, unit, custom_links, requests, check, group, group_by, grouping, tags, legend_size, show_legend, event_size, query, tags_execution, color, font_size, text, layout_type, widgets, events, yaxis, no_group_hosts, no_metric_hosts, node_type, notes, scope, style, url, margin, sizing, columns, indexes, logset, message_display, show_date_column, show_message_column, sort, color_preference, count, display_format, hide_zero_counts, show_last_triggered, start, summary_type, background_color, content, show_tick, tick_edge, tick_pos, autoscale, custom_unit, color_by_groups, xaxis, show_error_budget, slo_id, time_windows, view_mode, view_type, filters, service, env, show_breakdown, show_distribution, show_errors, show_hits, show_latency, show_resource_list, size_format, span_name, markers, right_yaxis].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      unless self.class.openapi_one_of.empty?
        for _class in self.class.openapi_one_of.each do
          _one_of = DatadogAPIClient::V1.const_get(_class).build_from_hash(attributes) rescue nil
          if _one_of != nil && _one_of.valid?
            return _one_of
          end
        end
      end
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        elsif attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          self.send("#{key}=", nil)
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        DatadogAPIClient::V1.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end
        
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
