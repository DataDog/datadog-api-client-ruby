=begin
#Datadog API V2 Collection

#Collection of all Datadog Public endpoints.

The version of the OpenAPI document: 1.0
Contact: support@datadoghq.com
Generated by: https://github.com/DataDog/datadog-api-client-ruby/tree/master/.generator

 Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 This product includes software developed at Datadog (https://www.datadoghq.com/).
 Copyright 2020-Present Datadog, Inc.

=end

require 'cgi'

module DatadogAPIClient::V2
  class SecurityMonitoringAPI
    attr_accessor :api_client

    def initialize(api_client = DatadogAPIClient::APIClient.default)
      @api_client = api_client
    end

    # Cancel a historical job.
    #
    # @see #cancel_historical_job_with_http_info
    def cancel_historical_job(job_id, opts = {})
      cancel_historical_job_with_http_info(job_id, opts)
      nil
    end

    # Cancel a historical job.
    #
    # Cancel a historical job.
    #
    # @param job_id [String] The ID of the job.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def cancel_historical_job_with_http_info(job_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.cancel_historical_job".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.cancel_historical_job")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.cancel_historical_job"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.cancel_historical_job ...'
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling SecurityMonitoringAPI.cancel_historical_job"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs/{job_id}/cancel'.sub('{job_id}', CGI.escape(job_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :cancel_historical_job,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#cancel_historical_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Convert an existing rule from JSON to Terraform.
    #
    # @see #convert_existing_security_monitoring_rule_with_http_info
    def convert_existing_security_monitoring_rule(rule_id, opts = {})
      data, _status_code, _headers = convert_existing_security_monitoring_rule_with_http_info(rule_id, opts)
      data
    end

    # Convert an existing rule from JSON to Terraform.
    #
    # Convert an existing rule from JSON to Terraform for datadog provider
    # resource datadog_security_monitoring_rule.
    #
    # @param rule_id [String] The ID of the rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleConvertResponse, Integer, Hash)>] SecurityMonitoringRuleConvertResponse data, response status code and response headers
    def convert_existing_security_monitoring_rule_with_http_info(rule_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.convert_existing_security_monitoring_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.convert_existing_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}/convert'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleConvertResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :convert_existing_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#convert_existing_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Convert a job result to a signal.
    #
    # @see #convert_job_result_to_signal_with_http_info
    def convert_job_result_to_signal(body, opts = {})
      convert_job_result_to_signal_with_http_info(body, opts)
      nil
    end

    # Convert a job result to a signal.
    #
    # Convert a job result to a signal.
    #
    # @param body [ConvertJobResultsToSignalsRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def convert_job_result_to_signal_with_http_info(body, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.convert_job_result_to_signal".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.convert_job_result_to_signal")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.convert_job_result_to_signal"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.convert_job_result_to_signal ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.convert_job_result_to_signal"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs/signal_convert'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :convert_job_result_to_signal,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#convert_job_result_to_signal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Convert a rule from JSON to Terraform.
    #
    # @see #convert_security_monitoring_rule_from_json_to_terraform_with_http_info
    def convert_security_monitoring_rule_from_json_to_terraform(body, opts = {})
      data, _status_code, _headers = convert_security_monitoring_rule_from_json_to_terraform_with_http_info(body, opts)
      data
    end

    # Convert a rule from JSON to Terraform.
    #
    # Convert a rule that doesn't (yet) exist from JSON to Terraform for datadog provider
    # resource datadog_security_monitoring_rule.
    #
    # @param body [SecurityMonitoringRuleConvertPayload] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleConvertResponse, Integer, Hash)>] SecurityMonitoringRuleConvertResponse data, response status code and response headers
    def convert_security_monitoring_rule_from_json_to_terraform_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.convert_security_monitoring_rule_from_json_to_terraform ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.convert_security_monitoring_rule_from_json_to_terraform"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/convert'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleConvertResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :convert_security_monitoring_rule_from_json_to_terraform,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#convert_security_monitoring_rule_from_json_to_terraform\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a custom framework.
    #
    # @see #create_custom_framework_with_http_info
    def create_custom_framework(body, opts = {})
      data, _status_code, _headers = create_custom_framework_with_http_info(body, opts)
      data
    end

    # Create a custom framework.
    #
    # Create a custom framework.
    #
    # @param body [CreateCustomFrameworkRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(CreateCustomFrameworkResponse, Integer, Hash)>] CreateCustomFrameworkResponse data, response status code and response headers
    def create_custom_framework_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_custom_framework ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_custom_framework"
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/custom_frameworks'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateCustomFrameworkResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :create_custom_framework,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_custom_framework\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a security filter.
    #
    # @see #create_security_filter_with_http_info
    def create_security_filter(body, opts = {})
      data, _status_code, _headers = create_security_filter_with_http_info(body, opts)
      data
    end

    # Create a security filter.
    #
    # Create a security filter.
    #
    # See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
    # for more examples.
    #
    # @param body [SecurityFilterCreateRequest] The definition of the new security filter.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityFilterResponse, Integer, Hash)>] SecurityFilterResponse data, response status code and response headers
    def create_security_filter_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_security_filter ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_security_filter"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/security_filters'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityFilterResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :create_security_filter,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_security_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a detection rule.
    #
    # @see #create_security_monitoring_rule_with_http_info
    def create_security_monitoring_rule(body, opts = {})
      data, _status_code, _headers = create_security_monitoring_rule_with_http_info(body, opts)
      data
    end

    # Create a detection rule.
    #
    # Create a detection rule.
    #
    # @param body [SecurityMonitoringRuleCreatePayload] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleResponse, Integer, Hash)>] SecurityMonitoringRuleResponse data, response status code and response headers
    def create_security_monitoring_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_security_monitoring_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :create_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a suppression rule.
    #
    # @see #create_security_monitoring_suppression_with_http_info
    def create_security_monitoring_suppression(body, opts = {})
      data, _status_code, _headers = create_security_monitoring_suppression_with_http_info(body, opts)
      data
    end

    # Create a suppression rule.
    #
    # Create a new suppression rule.
    #
    # @param body [SecurityMonitoringSuppressionCreateRequest] The definition of the new suppression rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionResponse, Integer, Hash)>] SecurityMonitoringSuppressionResponse data, response status code and response headers
    def create_security_monitoring_suppression_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_security_monitoring_suppression ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_security_monitoring_suppression"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :create_security_monitoring_suppression,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_security_monitoring_suppression\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new signal-based notification rule.
    #
    # @see #create_signal_notification_rule_with_http_info
    def create_signal_notification_rule(body, opts = {})
      data, _status_code, _headers = create_signal_notification_rule_with_http_info(body, opts)
      data
    end

    # Create a new signal-based notification rule.
    #
    # Create a new notification rule for security signals and return the created rule.
    #
    # @param body [CreateNotificationRuleParameters] The body of the create notification rule request is composed of the rule type and the rule attributes: the rule name, the selectors, the notification targets, and the rule enabled status. 
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def create_signal_notification_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_signal_notification_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_signal_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/signals/notification_rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :create_signal_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_signal_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new vulnerability-based notification rule.
    #
    # @see #create_vulnerability_notification_rule_with_http_info
    def create_vulnerability_notification_rule(body, opts = {})
      data, _status_code, _headers = create_vulnerability_notification_rule_with_http_info(body, opts)
      data
    end

    # Create a new vulnerability-based notification rule.
    #
    # Create a new notification rule for security vulnerabilities and return the created rule.
    #
    # @param body [CreateNotificationRuleParameters] The body of the create notification rule request is composed of the rule type and the rule attributes: the rule name, the selectors, the notification targets, and the rule enabled status. 
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def create_vulnerability_notification_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.create_vulnerability_notification_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.create_vulnerability_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities/notification_rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :create_vulnerability_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#create_vulnerability_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a custom framework.
    #
    # @see #delete_custom_framework_with_http_info
    def delete_custom_framework(handle, version, opts = {})
      data, _status_code, _headers = delete_custom_framework_with_http_info(handle, version, opts)
      data
    end

    # Delete a custom framework.
    #
    # Delete a custom framework.
    #
    # @param handle [String] The framework handle
    # @param version [String] The framework version
    # @param opts [Hash] the optional parameters
    # @return [Array<(DeleteCustomFrameworkResponse, Integer, Hash)>] DeleteCustomFrameworkResponse data, response status code and response headers
    def delete_custom_framework_with_http_info(handle, version, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_custom_framework ...'
      end
      # verify the required parameter 'handle' is set
      if @api_client.config.client_side_validation && handle.nil?
        fail ArgumentError, "Missing the required parameter 'handle' when calling SecurityMonitoringAPI.delete_custom_framework"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling SecurityMonitoringAPI.delete_custom_framework"
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/custom_frameworks/{handle}/{version}'.sub('{handle}', CGI.escape(handle.to_s).gsub('%2F', '/')).sub('{version}', CGI.escape(version.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeleteCustomFrameworkResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_custom_framework,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_custom_framework\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing job.
    #
    # @see #delete_historical_job_with_http_info
    def delete_historical_job(job_id, opts = {})
      delete_historical_job_with_http_info(job_id, opts)
      nil
    end

    # Delete an existing job.
    #
    # Delete an existing job.
    #
    # @param job_id [String] The ID of the job.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_historical_job_with_http_info(job_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.delete_historical_job".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.delete_historical_job")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.delete_historical_job"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_historical_job ...'
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling SecurityMonitoringAPI.delete_historical_job"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs/{job_id}'.sub('{job_id}', CGI.escape(job_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_historical_job,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_historical_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a security filter.
    #
    # @see #delete_security_filter_with_http_info
    def delete_security_filter(security_filter_id, opts = {})
      delete_security_filter_with_http_info(security_filter_id, opts)
      nil
    end

    # Delete a security filter.
    #
    # Delete a specific security filter.
    #
    # @param security_filter_id [String] The ID of the security filter.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_security_filter_with_http_info(security_filter_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_security_filter ...'
      end
      # verify the required parameter 'security_filter_id' is set
      if @api_client.config.client_side_validation && security_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'security_filter_id' when calling SecurityMonitoringAPI.delete_security_filter"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}'.sub('{security_filter_id}', CGI.escape(security_filter_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_security_filter,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_security_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing rule.
    #
    # @see #delete_security_monitoring_rule_with_http_info
    def delete_security_monitoring_rule(rule_id, opts = {})
      delete_security_monitoring_rule_with_http_info(rule_id, opts)
      nil
    end

    # Delete an existing rule.
    #
    # Delete an existing rule. Default rules cannot be deleted.
    #
    # @param rule_id [String] The ID of the rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_security_monitoring_rule_with_http_info(rule_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_security_monitoring_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.delete_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a suppression rule.
    #
    # @see #delete_security_monitoring_suppression_with_http_info
    def delete_security_monitoring_suppression(suppression_id, opts = {})
      delete_security_monitoring_suppression_with_http_info(suppression_id, opts)
      nil
    end

    # Delete a suppression rule.
    #
    # Delete a specific suppression rule.
    #
    # @param suppression_id [String] The ID of the suppression rule
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_security_monitoring_suppression_with_http_info(suppression_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_security_monitoring_suppression ...'
      end
      # verify the required parameter 'suppression_id' is set
      if @api_client.config.client_side_validation && suppression_id.nil?
        fail ArgumentError, "Missing the required parameter 'suppression_id' when calling SecurityMonitoringAPI.delete_security_monitoring_suppression"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/{suppression_id}'.sub('{suppression_id}', CGI.escape(suppression_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :delete_security_monitoring_suppression,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_security_monitoring_suppression\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a signal-based notification rule.
    #
    # @see #delete_signal_notification_rule_with_http_info
    def delete_signal_notification_rule(id, opts = {})
      delete_signal_notification_rule_with_http_info(id, opts)
      nil
    end

    # Delete a signal-based notification rule.
    #
    # Delete a notification rule for security signals.
    #
    # @param id [String] ID of the notification rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_signal_notification_rule_with_http_info(id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_signal_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.delete_signal_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/signals/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :delete_signal_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_signal_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a vulnerability-based notification rule.
    #
    # @see #delete_vulnerability_notification_rule_with_http_info
    def delete_vulnerability_notification_rule(id, opts = {})
      delete_vulnerability_notification_rule_with_http_info(id, opts)
      nil
    end

    # Delete a vulnerability-based notification rule.
    #
    # Delete a notification rule for security vulnerabilities.
    #
    # @param id [String] ID of the notification rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_vulnerability_notification_rule_with_http_info(id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.delete_vulnerability_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.delete_vulnerability_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :delete_vulnerability_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Delete, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#delete_vulnerability_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Modify the triage assignee of a security signal.
    #
    # @see #edit_security_monitoring_signal_assignee_with_http_info
    def edit_security_monitoring_signal_assignee(signal_id, body, opts = {})
      data, _status_code, _headers = edit_security_monitoring_signal_assignee_with_http_info(signal_id, body, opts)
      data
    end

    # Modify the triage assignee of a security signal.
    #
    # Modify the triage assignee of a security signal.
    #
    # @param signal_id [String] The ID of the signal.
    # @param body [SecurityMonitoringSignalAssigneeUpdateRequest] Attributes describing the signal update.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSignalTriageUpdateResponse, Integer, Hash)>] SecurityMonitoringSignalTriageUpdateResponse data, response status code and response headers
    def edit_security_monitoring_signal_assignee_with_http_info(signal_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.edit_security_monitoring_signal_assignee ...'
      end
      # verify the required parameter 'signal_id' is set
      if @api_client.config.client_side_validation && signal_id.nil?
        fail ArgumentError, "Missing the required parameter 'signal_id' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_assignee"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_assignee"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals/{signal_id}/assignee'.sub('{signal_id}', CGI.escape(signal_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalTriageUpdateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :edit_security_monitoring_signal_assignee,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#edit_security_monitoring_signal_assignee\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Change the related incidents of a security signal.
    #
    # @see #edit_security_monitoring_signal_incidents_with_http_info
    def edit_security_monitoring_signal_incidents(signal_id, body, opts = {})
      data, _status_code, _headers = edit_security_monitoring_signal_incidents_with_http_info(signal_id, body, opts)
      data
    end

    # Change the related incidents of a security signal.
    #
    # Change the related incidents for a security signal.
    #
    # @param signal_id [String] The ID of the signal.
    # @param body [SecurityMonitoringSignalIncidentsUpdateRequest] Attributes describing the signal update.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSignalTriageUpdateResponse, Integer, Hash)>] SecurityMonitoringSignalTriageUpdateResponse data, response status code and response headers
    def edit_security_monitoring_signal_incidents_with_http_info(signal_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.edit_security_monitoring_signal_incidents ...'
      end
      # verify the required parameter 'signal_id' is set
      if @api_client.config.client_side_validation && signal_id.nil?
        fail ArgumentError, "Missing the required parameter 'signal_id' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_incidents"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_incidents"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals/{signal_id}/incidents'.sub('{signal_id}', CGI.escape(signal_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalTriageUpdateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :edit_security_monitoring_signal_incidents,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#edit_security_monitoring_signal_incidents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Change the triage state of a security signal.
    #
    # @see #edit_security_monitoring_signal_state_with_http_info
    def edit_security_monitoring_signal_state(signal_id, body, opts = {})
      data, _status_code, _headers = edit_security_monitoring_signal_state_with_http_info(signal_id, body, opts)
      data
    end

    # Change the triage state of a security signal.
    #
    # Change the triage state of a security signal.
    #
    # @param signal_id [String] The ID of the signal.
    # @param body [SecurityMonitoringSignalStateUpdateRequest] Attributes describing the signal update.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSignalTriageUpdateResponse, Integer, Hash)>] SecurityMonitoringSignalTriageUpdateResponse data, response status code and response headers
    def edit_security_monitoring_signal_state_with_http_info(signal_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.edit_security_monitoring_signal_state ...'
      end
      # verify the required parameter 'signal_id' is set
      if @api_client.config.client_side_validation && signal_id.nil?
        fail ArgumentError, "Missing the required parameter 'signal_id' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_state"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.edit_security_monitoring_signal_state"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals/{signal_id}/state'.sub('{signal_id}', CGI.escape(signal_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalTriageUpdateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :edit_security_monitoring_signal_state,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#edit_security_monitoring_signal_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a custom framework.
    #
    # @see #get_custom_framework_with_http_info
    def get_custom_framework(handle, version, opts = {})
      data, _status_code, _headers = get_custom_framework_with_http_info(handle, version, opts)
      data
    end

    # Get a custom framework.
    #
    # Get a custom framework.
    #
    # @param handle [String] The framework handle
    # @param version [String] The framework version
    # @param opts [Hash] the optional parameters
    # @return [Array<(GetCustomFrameworkResponse, Integer, Hash)>] GetCustomFrameworkResponse data, response status code and response headers
    def get_custom_framework_with_http_info(handle, version, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_custom_framework ...'
      end
      # verify the required parameter 'handle' is set
      if @api_client.config.client_side_validation && handle.nil?
        fail ArgumentError, "Missing the required parameter 'handle' when calling SecurityMonitoringAPI.get_custom_framework"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling SecurityMonitoringAPI.get_custom_framework"
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/custom_frameworks/{handle}/{version}'.sub('{handle}', CGI.escape(handle.to_s).gsub('%2F', '/')).sub('{version}', CGI.escape(version.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetCustomFrameworkResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_custom_framework,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_custom_framework\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a finding.
    #
    # @see #get_finding_with_http_info
    def get_finding(finding_id, opts = {})
      data, _status_code, _headers = get_finding_with_http_info(finding_id, opts)
      data
    end

    # Get a finding.
    #
    # Returns a single finding with message and resource configuration.
    #
    # @param finding_id [String] The ID of the finding.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :snapshot_timestamp Return the finding for a given snapshot of time (Unix ms).
    # @return [Array<(GetFindingResponse, Integer, Hash)>] GetFindingResponse data, response status code and response headers
    def get_finding_with_http_info(finding_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_finding".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_finding")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_finding"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_finding ...'
      end
      # verify the required parameter 'finding_id' is set
      if @api_client.config.client_side_validation && finding_id.nil?
        fail ArgumentError, "Missing the required parameter 'finding_id' when calling SecurityMonitoringAPI.get_finding"
      end
      if @api_client.config.client_side_validation && !opts[:'snapshot_timestamp'].nil? && opts[:'snapshot_timestamp'] < 1
        fail ArgumentError, 'invalid value for "opts[:"snapshot_timestamp"]" when calling SecurityMonitoringAPI.get_finding, must be greater than or equal to 1.'
      end
      # resource path
      local_var_path = '/api/v2/posture_management/findings/{finding_id}'.sub('{finding_id}', CGI.escape(finding_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'snapshot_timestamp'] = opts[:'snapshot_timestamp'] if !opts[:'snapshot_timestamp'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetFindingResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_finding,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_finding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a job's details.
    #
    # @see #get_historical_job_with_http_info
    def get_historical_job(job_id, opts = {})
      data, _status_code, _headers = get_historical_job_with_http_info(job_id, opts)
      data
    end

    # Get a job's details.
    #
    # Get a job's details.
    #
    # @param job_id [String] The ID of the job.
    # @param opts [Hash] the optional parameters
    # @return [Array<(HistoricalJobResponse, Integer, Hash)>] HistoricalJobResponse data, response status code and response headers
    def get_historical_job_with_http_info(job_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_historical_job".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_historical_job")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_historical_job"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_historical_job ...'
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling SecurityMonitoringAPI.get_historical_job"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs/{job_id}'.sub('{job_id}', CGI.escape(job_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'HistoricalJobResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_historical_job,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_historical_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List resource filters.
    #
    # @see #get_resource_evaluation_filters_with_http_info
    def get_resource_evaluation_filters(opts = {})
      data, _status_code, _headers = get_resource_evaluation_filters_with_http_info(opts)
      data
    end

    # List resource filters.
    #
    # List resource filters.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :cloud_provider Filter resource filters by cloud provider (e.g. aws, gcp, azure).
    # @option opts [String] :account_id Filter resource filters by cloud provider account ID. This parameter is only valid when provider is specified.
    # @option opts [Boolean] :skip_cache Skip cache for resource filters.
    # @return [Array<(GetResourceEvaluationFiltersResponse, Integer, Hash)>] GetResourceEvaluationFiltersResponse data, response status code and response headers
    def get_resource_evaluation_filters_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_resource_evaluation_filters ...'
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/resource_filters'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cloud_provider'] = opts[:'cloud_provider'] if !opts[:'cloud_provider'].nil?
      query_params[:'account_id'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'skip_cache'] = opts[:'skip_cache'] if !opts[:'skip_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetResourceEvaluationFiltersResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_resource_evaluation_filters,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_resource_evaluation_filters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a rule's version history.
    #
    # @see #get_rule_version_history_with_http_info
    def get_rule_version_history(rule_id, opts = {})
      data, _status_code, _headers = get_rule_version_history_with_http_info(rule_id, opts)
      data
    end

    # Get a rule's version history.
    #
    # Get a rule's version history.
    #
    # @param rule_id [String] The ID of the rule.
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size Size for a given page. The maximum allowed value is 100. Test change to trigger client generation.
    # @option opts [Integer] :page_number Specific page number to return.
    # @return [Array<(GetRuleVersionHistoryResponse, Integer, Hash)>] GetRuleVersionHistoryResponse data, response status code and response headers
    def get_rule_version_history_with_http_info(rule_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_rule_version_history".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_rule_version_history")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_rule_version_history"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_rule_version_history ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.get_rule_version_history"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}/version_history'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[size]'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetRuleVersionHistoryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_rule_version_history,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_rule_version_history\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get SBOM.
    #
    # @see #get_sbom_with_http_info
    def get_sbom(asset_type, filter_asset_name, opts = {})
      data, _status_code, _headers = get_sbom_with_http_info(asset_type, filter_asset_name, opts)
      data
    end

    # Get SBOM.
    #
    # Get a single SBOM related to an asset by its type and name.
    #
    #
    # @param asset_type [AssetType] The type of the asset for the SBOM request.
    # @param filter_asset_name [String] The name of the asset for the SBOM request.
    # @param opts [Hash] the optional parameters
    # @option opts [String] :filter_repo_digest The container image `repo_digest` for the SBOM request. When the requested asset type is 'Image', this filter is mandatory.
    # @return [Array<(GetSBOMResponse, Integer, Hash)>] GetSBOMResponse data, response status code and response headers
    def get_sbom_with_http_info(asset_type, filter_asset_name, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_sbom".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_sbom")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_sbom"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_sbom ...'
      end
      # verify the required parameter 'asset_type' is set
      if @api_client.config.client_side_validation && asset_type.nil?
        fail ArgumentError, "Missing the required parameter 'asset_type' when calling SecurityMonitoringAPI.get_sbom"
      end
      # verify enum value
      allowable_values = ['Repository', 'Service', 'Host', 'HostImage', 'Image']
      if @api_client.config.client_side_validation && !allowable_values.include?(asset_type)
        fail ArgumentError, "invalid value for \"asset_type\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'filter_asset_name' is set
      if @api_client.config.client_side_validation && filter_asset_name.nil?
        fail ArgumentError, "Missing the required parameter 'filter_asset_name' when calling SecurityMonitoringAPI.get_sbom"
      end
      # resource path
      local_var_path = '/api/v2/security/sboms/{asset_type}'.sub('{asset_type}', CGI.escape(asset_type.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'filter[asset_name]'] = filter_asset_name
      query_params[:'filter[repo_digest]'] = opts[:'filter_repo_digest'] if !opts[:'filter_repo_digest'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetSBOMResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_sbom,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_sbom\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a security filter.
    #
    # @see #get_security_filter_with_http_info
    def get_security_filter(security_filter_id, opts = {})
      data, _status_code, _headers = get_security_filter_with_http_info(security_filter_id, opts)
      data
    end

    # Get a security filter.
    #
    # Get the details of a specific security filter.
    #
    # See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
    # for more examples.
    #
    # @param security_filter_id [String] The ID of the security filter.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityFilterResponse, Integer, Hash)>] SecurityFilterResponse data, response status code and response headers
    def get_security_filter_with_http_info(security_filter_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_filter ...'
      end
      # verify the required parameter 'security_filter_id' is set
      if @api_client.config.client_side_validation && security_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'security_filter_id' when calling SecurityMonitoringAPI.get_security_filter"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}'.sub('{security_filter_id}', CGI.escape(security_filter_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityFilterResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_filter,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a hist signal's details.
    #
    # @see #get_security_monitoring_histsignal_with_http_info
    def get_security_monitoring_histsignal(histsignal_id, opts = {})
      data, _status_code, _headers = get_security_monitoring_histsignal_with_http_info(histsignal_id, opts)
      data
    end

    # Get a hist signal's details.
    #
    # Get a hist signal's details.
    #
    # @param histsignal_id [String] The ID of the historical signal.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSignalResponse, Integer, Hash)>] SecurityMonitoringSignalResponse data, response status code and response headers
    def get_security_monitoring_histsignal_with_http_info(histsignal_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_security_monitoring_histsignal".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_security_monitoring_histsignal")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_security_monitoring_histsignal"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_monitoring_histsignal ...'
      end
      # verify the required parameter 'histsignal_id' is set
      if @api_client.config.client_side_validation && histsignal_id.nil?
        fail ArgumentError, "Missing the required parameter 'histsignal_id' when calling SecurityMonitoringAPI.get_security_monitoring_histsignal"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/histsignals/{histsignal_id}'.sub('{histsignal_id}', CGI.escape(histsignal_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_monitoring_histsignal,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_monitoring_histsignal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a job's hist signals.
    #
    # @see #get_security_monitoring_histsignals_by_job_id_with_http_info
    def get_security_monitoring_histsignals_by_job_id(job_id, opts = {})
      data, _status_code, _headers = get_security_monitoring_histsignals_by_job_id_with_http_info(job_id, opts)
      data
    end

    # Get a job's hist signals.
    #
    # Get a job's hist signals.
    #
    # @param job_id [String] The ID of the job.
    # @param opts [Hash] the optional parameters
    # @option opts [String] :filter_query The search query for security signals.
    # @option opts [Time] :filter_from The minimum timestamp for requested security signals.
    # @option opts [Time] :filter_to The maximum timestamp for requested security signals.
    # @option opts [SecurityMonitoringSignalsSort] :sort The order of the security signals in results.
    # @option opts [String] :page_cursor A list of results using the cursor provided in the previous query.
    # @option opts [Integer] :page_limit The maximum number of security signals in the response.
    # @return [Array<(SecurityMonitoringSignalsListResponse, Integer, Hash)>] SecurityMonitoringSignalsListResponse data, response status code and response headers
    def get_security_monitoring_histsignals_by_job_id_with_http_info(job_id, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.get_security_monitoring_histsignals_by_job_id".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.get_security_monitoring_histsignals_by_job_id")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.get_security_monitoring_histsignals_by_job_id"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_monitoring_histsignals_by_job_id ...'
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling SecurityMonitoringAPI.get_security_monitoring_histsignals_by_job_id"
      end
      allowable_values = ['timestamp', '-timestamp']
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'page_limit'].nil? && opts[:'page_limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_limit"]" when calling SecurityMonitoringAPI.get_security_monitoring_histsignals_by_job_id, must be smaller than or equal to 1000.'
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs/{job_id}/histsignals'.sub('{job_id}', CGI.escape(job_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'filter[query]'] = opts[:'filter_query'] if !opts[:'filter_query'].nil?
      query_params[:'filter[from]'] = opts[:'filter_from'] if !opts[:'filter_from'].nil?
      query_params[:'filter[to]'] = opts[:'filter_to'] if !opts[:'filter_to'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'page[cursor]'] = opts[:'page_cursor'] if !opts[:'page_cursor'].nil?
      query_params[:'page[limit]'] = opts[:'page_limit'] if !opts[:'page_limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_monitoring_histsignals_by_job_id,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_monitoring_histsignals_by_job_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a rule's details.
    #
    # @see #get_security_monitoring_rule_with_http_info
    def get_security_monitoring_rule(rule_id, opts = {})
      data, _status_code, _headers = get_security_monitoring_rule_with_http_info(rule_id, opts)
      data
    end

    # Get a rule's details.
    #
    # Get a rule's details.
    #
    # @param rule_id [String] The ID of the rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleResponse, Integer, Hash)>] SecurityMonitoringRuleResponse data, response status code and response headers
    def get_security_monitoring_rule_with_http_info(rule_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_monitoring_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.get_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a signal's details.
    #
    # @see #get_security_monitoring_signal_with_http_info
    def get_security_monitoring_signal(signal_id, opts = {})
      data, _status_code, _headers = get_security_monitoring_signal_with_http_info(signal_id, opts)
      data
    end

    # Get a signal's details.
    #
    # Get a signal's details.
    #
    # @param signal_id [String] The ID of the signal.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSignalResponse, Integer, Hash)>] SecurityMonitoringSignalResponse data, response status code and response headers
    def get_security_monitoring_signal_with_http_info(signal_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_monitoring_signal ...'
      end
      # verify the required parameter 'signal_id' is set
      if @api_client.config.client_side_validation && signal_id.nil?
        fail ArgumentError, "Missing the required parameter 'signal_id' when calling SecurityMonitoringAPI.get_security_monitoring_signal"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals/{signal_id}'.sub('{signal_id}', CGI.escape(signal_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_monitoring_signal,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_monitoring_signal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a suppression rule.
    #
    # @see #get_security_monitoring_suppression_with_http_info
    def get_security_monitoring_suppression(suppression_id, opts = {})
      data, _status_code, _headers = get_security_monitoring_suppression_with_http_info(suppression_id, opts)
      data
    end

    # Get a suppression rule.
    #
    # Get the details of a specific suppression rule.
    #
    # @param suppression_id [String] The ID of the suppression rule
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionResponse, Integer, Hash)>] SecurityMonitoringSuppressionResponse data, response status code and response headers
    def get_security_monitoring_suppression_with_http_info(suppression_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_security_monitoring_suppression ...'
      end
      # verify the required parameter 'suppression_id' is set
      if @api_client.config.client_side_validation && suppression_id.nil?
        fail ArgumentError, "Missing the required parameter 'suppression_id' when calling SecurityMonitoringAPI.get_security_monitoring_suppression"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/{suppression_id}'.sub('{suppression_id}', CGI.escape(suppression_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_security_monitoring_suppression,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_security_monitoring_suppression\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get details of a signal-based notification rule.
    #
    # @see #get_signal_notification_rule_with_http_info
    def get_signal_notification_rule(id, opts = {})
      data, _status_code, _headers = get_signal_notification_rule_with_http_info(id, opts)
      data
    end

    # Get details of a signal-based notification rule.
    #
    # Get the details of a notification rule for security signals.
    #
    # @param id [String] ID of the notification rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def get_signal_notification_rule_with_http_info(id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_signal_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.get_signal_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/signals/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_signal_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_signal_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the list of signal-based notification rules.
    #
    # @see #get_signal_notification_rules_with_http_info
    def get_signal_notification_rules(opts = {})
      data, _status_code, _headers = get_signal_notification_rules_with_http_info(opts)
      data
    end

    # Get the list of signal-based notification rules.
    #
    # Returns the list of notification rules for security signals.
    #
    # @param opts [Hash] the optional parameters
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def get_signal_notification_rules_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_signal_notification_rules ...'
      end
      # resource path
      local_var_path = '/api/v2/security/signals/notification_rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Object'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_signal_notification_rules,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_signal_notification_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get suppressions affecting future rule.
    #
    # @see #get_suppressions_affecting_future_rule_with_http_info
    def get_suppressions_affecting_future_rule(body, opts = {})
      data, _status_code, _headers = get_suppressions_affecting_future_rule_with_http_info(body, opts)
      data
    end

    # Get suppressions affecting future rule.
    #
    # Get the list of suppressions that would affect a rule.
    #
    # @param body [SecurityMonitoringRuleCreatePayload] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionsResponse, Integer, Hash)>] SecurityMonitoringSuppressionsResponse data, response status code and response headers
    def get_suppressions_affecting_future_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_suppressions_affecting_future_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.get_suppressions_affecting_future_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_suppressions_affecting_future_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_suppressions_affecting_future_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get suppressions affecting a specific rule.
    #
    # @see #get_suppressions_affecting_rule_with_http_info
    def get_suppressions_affecting_rule(rule_id, opts = {})
      data, _status_code, _headers = get_suppressions_affecting_rule_with_http_info(rule_id, opts)
      data
    end

    # Get suppressions affecting a specific rule.
    #
    # Get the list of suppressions that affect a specific existing rule by its ID.
    #
    # @param rule_id [String] The ID of the rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionsResponse, Integer, Hash)>] SecurityMonitoringSuppressionsResponse data, response status code and response headers
    def get_suppressions_affecting_rule_with_http_info(rule_id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_suppressions_affecting_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.get_suppressions_affecting_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/rules/{rule_id}'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :get_suppressions_affecting_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_suppressions_affecting_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get details of a vulnerability notification rule.
    #
    # @see #get_vulnerability_notification_rule_with_http_info
    def get_vulnerability_notification_rule(id, opts = {})
      data, _status_code, _headers = get_vulnerability_notification_rule_with_http_info(id, opts)
      data
    end

    # Get details of a vulnerability notification rule.
    #
    # Get the details of a notification rule for security vulnerabilities.
    #
    # @param id [String] ID of the notification rule.
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def get_vulnerability_notification_rule_with_http_info(id, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_vulnerability_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.get_vulnerability_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_vulnerability_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_vulnerability_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the list of vulnerability notification rules.
    #
    # @see #get_vulnerability_notification_rules_with_http_info
    def get_vulnerability_notification_rules(opts = {})
      data, _status_code, _headers = get_vulnerability_notification_rules_with_http_info(opts)
      data
    end

    # Get the list of vulnerability notification rules.
    #
    # Returns the list of notification rules for security vulnerabilities.
    #
    # @param opts [Hash] the optional parameters
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def get_vulnerability_notification_rules_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.get_vulnerability_notification_rules ...'
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities/notification_rules'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Object'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :get_vulnerability_notification_rules,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#get_vulnerability_notification_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List assets SBOMs.
    #
    # @see #list_assets_sbo_ms_with_http_info
    def list_assets_sbo_ms(opts = {})
      data, _status_code, _headers = list_assets_sbo_ms_with_http_info(opts)
      data
    end

    # List assets SBOMs.
    #
    # Get a list of assets SBOMs for an organization.
    #
    # ### Pagination
    #
    # Please review the [Pagination section](#pagination) for the "List Vulnerabilities" endpoint.
    #
    # ### Filtering
    #
    # Please review the [Filtering section](#filtering) for the "List Vulnerabilities" endpoint.
    #
    # ### Metadata
    #
    # Please review the [Metadata section](#metadata) for the "List Vulnerabilities" endpoint.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :page_token Its value must come from the `links` section of the response of the first request. Do not manually edit it.
    # @option opts [Integer] :page_number The page number to be retrieved. It should be equal to or greater than 1.
    # @option opts [AssetType] :filter_asset_type The type of the assets for the SBOM request.
    # @option opts [String] :filter_asset_name The name of the asset for the SBOM request.
    # @option opts [String] :filter_package_name The name of the component that is a dependency of an asset.
    # @option opts [String] :filter_package_version The version of the component that is a dependency of an asset.
    # @option opts [String] :filter_license_name The software license name of the component that is a dependency of an asset.
    # @option opts [SBOMComponentLicenseType] :filter_license_type The software license type of the component that is a dependency of an asset.
    # @return [Array<(ListAssetsSBOMsResponse, Integer, Hash)>] ListAssetsSBOMsResponse data, response status code and response headers
    def list_assets_sbo_ms_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_assets_sbo_ms".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_assets_sbo_ms")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_assets_sbo_ms"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_assets_sbo_ms ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_number'].nil? && opts[:'page_number'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_number"]" when calling SecurityMonitoringAPI.list_assets_sbo_ms, must be greater than or equal to 1.'
      end
      allowable_values = ['Repository', 'Service', 'Host', 'HostImage', 'Image']
      if @api_client.config.client_side_validation && opts[:'filter_asset_type'] && !allowable_values.include?(opts[:'filter_asset_type'])
        fail ArgumentError, "invalid value for \"filter_asset_type\", must be one of #{allowable_values}"
      end
      allowable_values = ['network_strong_copyleft', 'non_standard_copyleft', 'other_non_free', 'other_non_standard', 'permissive', 'public_domain', 'strong_copyleft', 'weak_copyleft']
      if @api_client.config.client_side_validation && opts[:'filter_license_type'] && !allowable_values.include?(opts[:'filter_license_type'])
        fail ArgumentError, "invalid value for \"filter_license_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v2/security/sboms'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[token]'] = opts[:'page_token'] if !opts[:'page_token'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'filter[asset_type]'] = opts[:'filter_asset_type'] if !opts[:'filter_asset_type'].nil?
      query_params[:'filter[asset_name]'] = opts[:'filter_asset_name'] if !opts[:'filter_asset_name'].nil?
      query_params[:'filter[package_name]'] = opts[:'filter_package_name'] if !opts[:'filter_package_name'].nil?
      query_params[:'filter[package_version]'] = opts[:'filter_package_version'] if !opts[:'filter_package_version'].nil?
      query_params[:'filter[license_name]'] = opts[:'filter_license_name'] if !opts[:'filter_license_name'].nil?
      query_params[:'filter[license_type]'] = opts[:'filter_license_type'] if !opts[:'filter_license_type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListAssetsSBOMsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :list_assets_sbo_ms,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_assets_sbo_ms\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List findings.
    #
    # @see #list_findings_with_http_info
    def list_findings(opts = {})
      data, _status_code, _headers = list_findings_with_http_info(opts)
      data
    end

    # List findings.
    #
    # Get a list of findings. These include both misconfigurations and identity risks.
    #
    # **Note**: To filter and return only identity risks, add the following query parameter: `?filter[tags]=dd_rule_type:ciem`
    #
    # ### Filtering
    #
    # Filters can be applied by appending query parameters to the URL.
    #
    #   - Using a single filter: `?filter[attribute_key]=attribute_value`
    #   - Chaining filters: `?filter[attribute_key]=attribute_value&filter[attribute_key]=attribute_value...`
    #   - Filtering on tags: `?filter[tags]=tag_key:tag_value&filter[tags]=tag_key_2:tag_value_2`
    #
    # Here, `attribute_key` can be any of the filter keys described further below.
    #
    # Query parameters of type `integer` support comparison operators (`>`, `>=`, `<`, `<=`). This is particularly useful when filtering by `evaluation_changed_at` or `resource_discovery_timestamp`. For example: `?filter[evaluation_changed_at]=>20123123121`.
    #
    # You can also use the negation operator on strings. For example, use `filter[resource_type]=-aws*` to filter for any non-AWS resources.
    #
    # The operator must come after the equal sign. For example, to filter with the `>=` operator, add the operator after the equal sign: `filter[evaluation_changed_at]=>=1678809373257`.
    #
    # Query parameters must be only among the documented ones and with values of correct types. Duplicated query parameters (e.g. `filter[status]=low&filter[status]=info`) are not allowed.
    #
    # ### Additional extension fields
    #
    # Additional extension fields are available for some findings.
    #
    # The data is available when you include the query parameter `?detailed_findings=true` in the request.
    #
    # The following fields are available for findings:
    # - `external_id`: The resource external ID related to the finding.
    # - `description`: The description and remediation steps for the finding.
    # - `datadog_link`: The Datadog relative link for the finding.
    # - `ip_addresses`: The list of private IP addresses for the resource related to the finding.
    #
    # ### Response
    #
    # The response includes an array of finding objects, pagination metadata, and a count of items that match the query.
    #
    # Each finding object contains the following:
    #
    # - The finding ID that can be used in a `GetFinding` request to retrieve the full finding details.
    # - Core attributes, including status, evaluation, high-level resource details, muted state, and rule details.
    # - `evaluation_changed_at` and `resource_discovery_date` time stamps.
    # - An array of associated tags.
    #
    #
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_limit Limit the number of findings returned. Must be <= 1000.
    # @option opts [Integer] :snapshot_timestamp Return findings for a given snapshot of time (Unix ms).
    # @option opts [String] :page_cursor Return the next page of findings pointed to by the cursor.
    # @option opts [String] :filter_tags Return findings that have these associated tags (repeatable).
    # @option opts [String] :filter_evaluation_changed_at Return findings that have changed from pass to fail or vice versa on a specified date (Unix ms) or date range (using comparison operators).
    # @option opts [Boolean] :filter_muted Set to `true` to return findings that are muted. Set to `false` to return unmuted findings.
    # @option opts [String] :filter_rule_id Return findings for the specified rule ID.
    # @option opts [String] :filter_rule_name Return findings for the specified rule.
    # @option opts [String] :filter_resource_type Return only findings for the specified resource type.
    # @option opts [String] :filter_resource_id Return only findings for the specified resource id.
    # @option opts [String] :filter_discovery_timestamp Return findings that were found on a specified date (Unix ms) or date range (using comparison operators).
    # @option opts [FindingEvaluation] :filter_evaluation Return only `pass` or `fail` findings.
    # @option opts [FindingStatus] :filter_status Return only findings with the specified status.
    # @option opts [Array<FindingVulnerabilityType>] :filter_vulnerability_type Return findings that match the selected vulnerability types (repeatable).
    # @option opts [Boolean] :detailed_findings Return additional fields for some findings.
    # @return [Array<(ListFindingsResponse, Integer, Hash)>] ListFindingsResponse data, response status code and response headers
    def list_findings_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_findings".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_findings")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_findings"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_findings ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_limit'].nil? && opts[:'page_limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_limit"]" when calling SecurityMonitoringAPI.list_findings, must be smaller than or equal to 1000.'
      end
      if @api_client.config.client_side_validation && !opts[:'page_limit'].nil? && opts[:'page_limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_limit"]" when calling SecurityMonitoringAPI.list_findings, must be greater than or equal to 1.'
      end
      if @api_client.config.client_side_validation && !opts[:'snapshot_timestamp'].nil? && opts[:'snapshot_timestamp'] < 1
        fail ArgumentError, 'invalid value for "opts[:"snapshot_timestamp"]" when calling SecurityMonitoringAPI.list_findings, must be greater than or equal to 1.'
      end
      allowable_values = ['pass', 'fail']
      if @api_client.config.client_side_validation && opts[:'filter_evaluation'] && !allowable_values.include?(opts[:'filter_evaluation'])
        fail ArgumentError, "invalid value for \"filter_evaluation\", must be one of #{allowable_values}"
      end
      allowable_values = ['critical', 'high', 'medium', 'low', 'info']
      if @api_client.config.client_side_validation && opts[:'filter_status'] && !allowable_values.include?(opts[:'filter_status'])
        fail ArgumentError, "invalid value for \"filter_status\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v2/posture_management/findings'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[limit]'] = opts[:'page_limit'] if !opts[:'page_limit'].nil?
      query_params[:'snapshot_timestamp'] = opts[:'snapshot_timestamp'] if !opts[:'snapshot_timestamp'].nil?
      query_params[:'page[cursor]'] = opts[:'page_cursor'] if !opts[:'page_cursor'].nil?
      query_params[:'filter[tags]'] = opts[:'filter_tags'] if !opts[:'filter_tags'].nil?
      query_params[:'filter[evaluation_changed_at]'] = opts[:'filter_evaluation_changed_at'] if !opts[:'filter_evaluation_changed_at'].nil?
      query_params[:'filter[muted]'] = opts[:'filter_muted'] if !opts[:'filter_muted'].nil?
      query_params[:'filter[rule_id]'] = opts[:'filter_rule_id'] if !opts[:'filter_rule_id'].nil?
      query_params[:'filter[rule_name]'] = opts[:'filter_rule_name'] if !opts[:'filter_rule_name'].nil?
      query_params[:'filter[resource_type]'] = opts[:'filter_resource_type'] if !opts[:'filter_resource_type'].nil?
      query_params[:'filter[@resource_id]'] = opts[:'filter_resource_id'] if !opts[:'filter_resource_id'].nil?
      query_params[:'filter[discovery_timestamp]'] = opts[:'filter_discovery_timestamp'] if !opts[:'filter_discovery_timestamp'].nil?
      query_params[:'filter[evaluation]'] = opts[:'filter_evaluation'] if !opts[:'filter_evaluation'].nil?
      query_params[:'filter[status]'] = opts[:'filter_status'] if !opts[:'filter_status'].nil?
      query_params[:'filter[vulnerability_type]'] = @api_client.build_collection_param(opts[:'filter_vulnerability_type'], :multi) if !opts[:'filter_vulnerability_type'].nil?
      query_params[:'detailed_findings'] = opts[:'detailed_findings'] if !opts[:'detailed_findings'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListFindingsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_findings,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )
      new_options[:query_string_normalizer] = HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_findings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List findings.
    #
    # Provide a paginated version of {#list_findings}, returning all items.
    #
    # To use it you need to use a block: list_findings_with_pagination { |item| p item }
    #
    # @yield [Finding] Paginated items
    def list_findings_with_pagination(opts = {})
        api_version = "V2"
        page_size = @api_client.get_attribute_from_path(opts, "page_limit", 100)
        @api_client.set_attribute_from_path(api_version, opts, "page_limit", Integer, page_size)
        while true do
            response = list_findings(opts)
            @api_client.get_attribute_from_path(response, "data").each { |item| yield(item) }
            if @api_client.get_attribute_from_path(response, "data").length < page_size
              break
            end
            @api_client.set_attribute_from_path(api_version, opts, "page_cursor", String, @api_client.get_attribute_from_path(response, "meta.page.cursor"))
        end
    end

    # List historical jobs.
    #
    # @see #list_historical_jobs_with_http_info
    def list_historical_jobs(opts = {})
      data, _status_code, _headers = list_historical_jobs_with_http_info(opts)
      data
    end

    # List historical jobs.
    #
    # List historical jobs.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size Size for a given page. The maximum allowed value is 100. Test change to trigger client generation.
    # @option opts [Integer] :page_number Specific page number to return.
    # @option opts [String] :sort The order of the jobs in results.
    # @option opts [String] :filter_query Query used to filter items from the fetched list.
    # @return [Array<(ListHistoricalJobsResponse, Integer, Hash)>] ListHistoricalJobsResponse data, response status code and response headers
    def list_historical_jobs_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_historical_jobs".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_historical_jobs")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_historical_jobs"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_historical_jobs ...'
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[size]'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'filter[query]'] = opts[:'filter_query'] if !opts[:'filter_query'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListHistoricalJobsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_historical_jobs,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_historical_jobs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all security filters.
    #
    # @see #list_security_filters_with_http_info
    def list_security_filters(opts = {})
      data, _status_code, _headers = list_security_filters_with_http_info(opts)
      data
    end

    # Get all security filters.
    #
    # Get the list of configured security filters with their definitions.
    #
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityFiltersResponse, Integer, Hash)>] SecurityFiltersResponse data, response status code and response headers
    def list_security_filters_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_security_filters ...'
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/security_filters'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityFiltersResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_security_filters,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_security_filters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List hist signals.
    #
    # @see #list_security_monitoring_histsignals_with_http_info
    def list_security_monitoring_histsignals(opts = {})
      data, _status_code, _headers = list_security_monitoring_histsignals_with_http_info(opts)
      data
    end

    # List hist signals.
    #
    # List hist signals.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :filter_query The search query for security signals.
    # @option opts [Time] :filter_from The minimum timestamp for requested security signals.
    # @option opts [Time] :filter_to The maximum timestamp for requested security signals.
    # @option opts [SecurityMonitoringSignalsSort] :sort The order of the security signals in results.
    # @option opts [String] :page_cursor A list of results using the cursor provided in the previous query.
    # @option opts [Integer] :page_limit The maximum number of security signals in the response.
    # @return [Array<(SecurityMonitoringSignalsListResponse, Integer, Hash)>] SecurityMonitoringSignalsListResponse data, response status code and response headers
    def list_security_monitoring_histsignals_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_security_monitoring_histsignals".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_security_monitoring_histsignals")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_security_monitoring_histsignals"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_security_monitoring_histsignals ...'
      end
      allowable_values = ['timestamp', '-timestamp']
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'page_limit'].nil? && opts[:'page_limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_limit"]" when calling SecurityMonitoringAPI.list_security_monitoring_histsignals, must be smaller than or equal to 1000.'
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/histsignals'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'filter[query]'] = opts[:'filter_query'] if !opts[:'filter_query'].nil?
      query_params[:'filter[from]'] = opts[:'filter_from'] if !opts[:'filter_from'].nil?
      query_params[:'filter[to]'] = opts[:'filter_to'] if !opts[:'filter_to'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'page[cursor]'] = opts[:'page_cursor'] if !opts[:'page_cursor'].nil?
      query_params[:'page[limit]'] = opts[:'page_limit'] if !opts[:'page_limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_security_monitoring_histsignals,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_security_monitoring_histsignals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List rules.
    #
    # @see #list_security_monitoring_rules_with_http_info
    def list_security_monitoring_rules(opts = {})
      data, _status_code, _headers = list_security_monitoring_rules_with_http_info(opts)
      data
    end

    # List rules.
    #
    # List rules.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [Integer] :page_size Size for a given page. The maximum allowed value is 100. Test change to trigger client generation.
    # @option opts [Integer] :page_number Specific page number to return.
    # @return [Array<(SecurityMonitoringListRulesResponse, Integer, Hash)>] SecurityMonitoringListRulesResponse data, response status code and response headers
    def list_security_monitoring_rules_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_security_monitoring_rules ...'
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[size]'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringListRulesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_security_monitoring_rules,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_security_monitoring_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a quick list of security signals.
    #
    # @see #list_security_monitoring_signals_with_http_info
    def list_security_monitoring_signals(opts = {})
      data, _status_code, _headers = list_security_monitoring_signals_with_http_info(opts)
      data
    end

    # Get a quick list of security signals.
    #
    # The list endpoint returns security signals that match a search query.
    # Both this endpoint and the POST endpoint can be used interchangeably when listing
    # security signals.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :filter_query The search query for security signals.
    # @option opts [Time] :filter_from The minimum timestamp for requested security signals.
    # @option opts [Time] :filter_to The maximum timestamp for requested security signals.
    # @option opts [SecurityMonitoringSignalsSort] :sort The order of the security signals in results.
    # @option opts [String] :page_cursor A list of results using the cursor provided in the previous query.
    # @option opts [Integer] :page_limit The maximum number of security signals in the response.
    # @return [Array<(SecurityMonitoringSignalsListResponse, Integer, Hash)>] SecurityMonitoringSignalsListResponse data, response status code and response headers
    def list_security_monitoring_signals_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_security_monitoring_signals ...'
      end
      allowable_values = ['timestamp', '-timestamp']
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'page_limit'].nil? && opts[:'page_limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_limit"]" when calling SecurityMonitoringAPI.list_security_monitoring_signals, must be smaller than or equal to 1000.'
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'filter[query]'] = opts[:'filter_query'] if !opts[:'filter_query'].nil?
      query_params[:'filter[from]'] = opts[:'filter_from'] if !opts[:'filter_from'].nil?
      query_params[:'filter[to]'] = opts[:'filter_to'] if !opts[:'filter_to'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'page[cursor]'] = opts[:'page_cursor'] if !opts[:'page_cursor'].nil?
      query_params[:'page[limit]'] = opts[:'page_limit'] if !opts[:'page_limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_security_monitoring_signals,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_security_monitoring_signals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a quick list of security signals.
    #
    # Provide a paginated version of {#list_security_monitoring_signals}, returning all items.
    #
    # To use it you need to use a block: list_security_monitoring_signals_with_pagination { |item| p item }
    #
    # @yield [SecurityMonitoringSignal] Paginated items
    def list_security_monitoring_signals_with_pagination(opts = {})
        api_version = "V2"
        page_size = @api_client.get_attribute_from_path(opts, "page_limit", 10)
        @api_client.set_attribute_from_path(api_version, opts, "page_limit", Integer, page_size)
        while true do
            response = list_security_monitoring_signals(opts)
            @api_client.get_attribute_from_path(response, "data").each { |item| yield(item) }
            if @api_client.get_attribute_from_path(response, "data").length < page_size
              break
            end
            @api_client.set_attribute_from_path(api_version, opts, "page_cursor", String, @api_client.get_attribute_from_path(response, "meta.page.after"))
        end
    end

    # Get all suppression rules.
    #
    # @see #list_security_monitoring_suppressions_with_http_info
    def list_security_monitoring_suppressions(opts = {})
      data, _status_code, _headers = list_security_monitoring_suppressions_with_http_info(opts)
      data
    end

    # Get all suppression rules.
    #
    # Get the list of all suppression rules.
    #
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionsResponse, Integer, Hash)>] SecurityMonitoringSuppressionsResponse data, response status code and response headers
    def list_security_monitoring_suppressions_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_security_monitoring_suppressions ...'
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :list_security_monitoring_suppressions,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_security_monitoring_suppressions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List vulnerabilities.
    #
    # @see #list_vulnerabilities_with_http_info
    def list_vulnerabilities(opts = {})
      data, _status_code, _headers = list_vulnerabilities_with_http_info(opts)
      data
    end

    # List vulnerabilities.
    #
    # Get a list of vulnerabilities.
    #
    # ### Pagination
    #
    # Pagination is enabled by default in both `vulnerabilities` and `assets`. The size of the page varies depending on the endpoint and cannot be modified. To automate the request of the next page, you can use the links section in the response.
    #
    # This endpoint will return paginated responses. The pages are stored in the links section of the response:
    #
    # ```JSON
    # {
    #   "data": [...],
    #   "meta": {...},
    #   "links": {
    #     "self": "https://.../api/v2/security/vulnerabilities",
    #     "first": "https://.../api/v2/security/vulnerabilities?page[number]=1&page[token]=abc",
    #     "last": "https://.../api/v2/security/vulnerabilities?page[number]=43&page[token]=abc",
    #     "next": "https://.../api/v2/security/vulnerabilities?page[number]=2&page[token]=abc"
    #   }
    # }
    # ```
    #
    #
    # - `links.previous` is empty if the first page is requested.
    # - `links.next` is empty if the last page is requested.
    #
    # #### Token
    #
    # Vulnerabilities can be created, updated or deleted at any point in time.
    #
    # Upon the first request, a token is created to ensure consistency across subsequent paginated requests.
    #
    # A token is valid only for 24 hours.
    #
    # #### First request
    #
    # We consider a request to be the first request when there is no `page[token]` parameter.
    #
    # The response of this first request contains the newly created token in the `links` section.
    #
    # This token can then be used in the subsequent paginated requests.
    #
    # #### Subsequent requests
    #
    # Any request containing valid `page[token]` and `page[number]` parameters will be considered a subsequent request.
    #
    # If the `token` is invalid, a `404` response will be returned.
    #
    # If the page `number` is invalid, a `400` response will be returned.
    #
    # ### Filtering
    #
    # The request can include some filter parameters to filter the data to be retrieved. The format of the filter parameters follows the [JSON:API format](https://jsonapi.org/format/#fetching-filtering): `filter[$prop_name]`, where `prop_name` is the property name in the entity being filtered by.
    #
    # All filters can include multiple values, where data will be filtered with an OR clause: `filter[title]=Title1,Title2` will filter all vulnerabilities where title is equal to `Title1` OR `Title2`.
    #
    # String filters are case sensitive.
    #
    # Boolean filters accept `true` or `false` as values.
    #
    # Number filters must include an operator as a second filter input: `filter[$prop_name][$operator]`. For example, for the vulnerabilities endpoint: `filter[cvss.base.score][lte]=8`.
    #
    # Available operators are: `eq` (==), `lt` (<), `lte` (<=), `gt` (>) and `gte` (>=).
    #
    # ### Metadata
    #
    # Following [JSON:API format](https://jsonapi.org/format/#document-meta), object including non-standard meta-information.
    #
    # This endpoint includes the meta member in the response. For more details on each of the properties included in this section, check the endpoints response tables.
    #
    # ```JSON
    # {
    #   "data": [...],
    #   "meta": {
    #     "total": 1500,
    #     "count": 18732,
    #     "token": "some_token"
    #   },
    #   "links": {...}
    # }
    # ```
    #
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :page_token Its value must come from the `links` section of the response of the first request. Do not manually edit it.
    # @option opts [Integer] :page_number The page number to be retrieved. It should be equal or greater than `1`
    # @option opts [VulnerabilityType] :filter_type Filter by vulnerability type.
    # @option opts [Float] :filter_cvss_base_score_op Filter by vulnerability base (i.e. from the original advisory) severity score.
    # @option opts [VulnerabilitySeverity] :filter_cvss_base_severity Filter by vulnerability base severity.
    # @option opts [String] :filter_cvss_base_vector Filter by vulnerability base CVSS vector.
    # @option opts [Float] :filter_cvss_datadog_score_op Filter by vulnerability Datadog severity score.
    # @option opts [VulnerabilitySeverity] :filter_cvss_datadog_severity Filter by vulnerability Datadog severity.
    # @option opts [String] :filter_cvss_datadog_vector Filter by vulnerability Datadog CVSS vector.
    # @option opts [VulnerabilityStatus] :filter_status Filter by the status of the vulnerability.
    # @option opts [VulnerabilityTool] :filter_tool Filter by the tool of the vulnerability.
    # @option opts [String] :filter_library_name Filter by library name.
    # @option opts [String] :filter_library_version Filter by library version.
    # @option opts [String] :filter_advisory_id Filter by advisory ID.
    # @option opts [Boolean] :filter_risks_exploitation_probability Filter by exploitation probability.
    # @option opts [Boolean] :filter_risks_poc_exploit_available Filter by POC exploit availability.
    # @option opts [Boolean] :filter_risks_exploit_available Filter by public exploit availability.
    # @option opts [Float] :filter_risks_epss_score_op Filter by vulnerability [EPSS](https://www.first.org/epss/) severity score.
    # @option opts [VulnerabilitySeverity] :filter_risks_epss_severity Filter by vulnerability [EPSS](https://www.first.org/epss/) severity.
    # @option opts [String] :filter_language Filter by language.
    # @option opts [VulnerabilityEcosystem] :filter_ecosystem Filter by ecosystem.
    # @option opts [String] :filter_code_location_location Filter by vulnerability location.
    # @option opts [String] :filter_code_location_file_path Filter by vulnerability file path.
    # @option opts [String] :filter_code_location_method Filter by method.
    # @option opts [Boolean] :filter_fix_available Filter by fix availability.
    # @option opts [String] :filter_repo_digests Filter by vulnerability `repo_digest` (when the vulnerability is related to `Image` asset).
    # @option opts [String] :filter_origin Filter by origin.
    # @option opts [String] :filter_asset_name Filter by asset name.
    # @option opts [AssetType] :filter_asset_type Filter by asset type.
    # @option opts [String] :filter_asset_version_first Filter by the first version of the asset this vulnerability has been detected on.
    # @option opts [String] :filter_asset_version_last Filter by the last version of the asset this vulnerability has been detected on.
    # @option opts [String] :filter_asset_repository_url Filter by the repository url associated to the asset.
    # @option opts [Boolean] :filter_asset_risks_in_production Filter whether the asset is in production or not.
    # @option opts [Boolean] :filter_asset_risks_under_attack Filter whether the asset is under attack or not.
    # @option opts [Boolean] :filter_asset_risks_is_publicly_accessible Filter whether the asset is publicly accessible or not.
    # @option opts [Boolean] :filter_asset_risks_has_privileged_access Filter whether the asset is publicly accessible or not.
    # @option opts [Boolean] :filter_asset_risks_has_access_to_sensitive_data Filter whether the asset  has access to sensitive data or not.
    # @option opts [String] :filter_asset_environments Filter by asset environments.
    # @option opts [String] :filter_asset_teams Filter by asset teams.
    # @option opts [String] :filter_asset_arch Filter by asset architecture.
    # @option opts [String] :filter_asset_operating_system_name Filter by asset operating system name.
    # @option opts [String] :filter_asset_operating_system_version Filter by asset operating system version.
    # @return [Array<(ListVulnerabilitiesResponse, Integer, Hash)>] ListVulnerabilitiesResponse data, response status code and response headers
    def list_vulnerabilities_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_vulnerabilities".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_vulnerabilities")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_vulnerabilities"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_vulnerabilities ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_number'].nil? && opts[:'page_number'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_number"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be greater than or equal to 1.'
      end
      allowable_values = ['AdminConsoleActive', 'CodeInjection', 'CommandInjection', 'ComponentWithKnownVulnerability', 'DangerousWorkflows', 'DefaultAppDeployed', 'DefaultHtmlEscapeInvalid', 'DirectoryListingLeak', 'EmailHtmlInjection', 'EndOfLife', 'HardcodedPassword', 'HardcodedSecret', 'HeaderInjection', 'HstsHeaderMissing', 'InsecureAuthProtocol', 'InsecureCookie', 'InsecureJspLayout', 'LdapInjection', 'MaliciousPackage', 'MandatoryRemediation', 'NoHttpOnlyCookie', 'NoSameSiteCookie', 'NoSqlMongoDbInjection', 'PathTraversal', 'ReflectionInjection', 'RiskyLicense', 'SessionRewriting', 'SessionTimeout', 'SqlInjection', 'Ssrf', 'StackTraceLeak', 'TrustBoundaryViolation', 'Unmaintained', 'UntrustedDeserialization', 'UnvalidatedRedirect', 'VerbTampering', 'WeakCipher', 'WeakHash', 'WeakRandomness', 'XContentTypeHeaderMissing', 'XPathInjection', 'Xss']
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !allowable_values.include?(opts[:'filter_type'])
        fail ArgumentError, "invalid value for \"filter_type\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'filter_cvss_base_score_op'].nil? && opts[:'filter_cvss_base_score_op'] > 10
        fail ArgumentError, 'invalid value for "opts[:"filter_cvss_base_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be smaller than or equal to 10.'
      end
      if @api_client.config.client_side_validation && !opts[:'filter_cvss_base_score_op'].nil? && opts[:'filter_cvss_base_score_op'] < 0
        fail ArgumentError, 'invalid value for "opts[:"filter_cvss_base_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be greater than or equal to 0.'
      end
      allowable_values = ['Unknown', 'None', 'Low', 'Medium', 'High', 'Critical']
      if @api_client.config.client_side_validation && opts[:'filter_cvss_base_severity'] && !allowable_values.include?(opts[:'filter_cvss_base_severity'])
        fail ArgumentError, "invalid value for \"filter_cvss_base_severity\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'filter_cvss_datadog_score_op'].nil? && opts[:'filter_cvss_datadog_score_op'] > 10
        fail ArgumentError, 'invalid value for "opts[:"filter_cvss_datadog_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be smaller than or equal to 10.'
      end
      if @api_client.config.client_side_validation && !opts[:'filter_cvss_datadog_score_op'].nil? && opts[:'filter_cvss_datadog_score_op'] < 0
        fail ArgumentError, 'invalid value for "opts[:"filter_cvss_datadog_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be greater than or equal to 0.'
      end
      allowable_values = ['Unknown', 'None', 'Low', 'Medium', 'High', 'Critical']
      if @api_client.config.client_side_validation && opts[:'filter_cvss_datadog_severity'] && !allowable_values.include?(opts[:'filter_cvss_datadog_severity'])
        fail ArgumentError, "invalid value for \"filter_cvss_datadog_severity\", must be one of #{allowable_values}"
      end
      allowable_values = ['Open', 'Muted', 'Remediated', 'InProgress', 'AutoClosed']
      if @api_client.config.client_side_validation && opts[:'filter_status'] && !allowable_values.include?(opts[:'filter_status'])
        fail ArgumentError, "invalid value for \"filter_status\", must be one of #{allowable_values}"
      end
      allowable_values = ['IAST', 'SCA', 'Infra']
      if @api_client.config.client_side_validation && opts[:'filter_tool'] && !allowable_values.include?(opts[:'filter_tool'])
        fail ArgumentError, "invalid value for \"filter_tool\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'filter_risks_epss_score_op'].nil? && opts[:'filter_risks_epss_score_op'] > 1
        fail ArgumentError, 'invalid value for "opts[:"filter_risks_epss_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be smaller than or equal to 1.'
      end
      if @api_client.config.client_side_validation && !opts[:'filter_risks_epss_score_op'].nil? && opts[:'filter_risks_epss_score_op'] < 0
        fail ArgumentError, 'invalid value for "opts[:"filter_risks_epss_score_op"]" when calling SecurityMonitoringAPI.list_vulnerabilities, must be greater than or equal to 0.'
      end
      allowable_values = ['Unknown', 'None', 'Low', 'Medium', 'High', 'Critical']
      if @api_client.config.client_side_validation && opts[:'filter_risks_epss_severity'] && !allowable_values.include?(opts[:'filter_risks_epss_severity'])
        fail ArgumentError, "invalid value for \"filter_risks_epss_severity\", must be one of #{allowable_values}"
      end
      allowable_values = ['PyPI', 'Maven', 'NuGet', 'Npm', 'RubyGems', 'Go', 'Packagist', 'Ddeb', 'Rpm', 'Apk', 'Windows']
      if @api_client.config.client_side_validation && opts[:'filter_ecosystem'] && !allowable_values.include?(opts[:'filter_ecosystem'])
        fail ArgumentError, "invalid value for \"filter_ecosystem\", must be one of #{allowable_values}"
      end
      allowable_values = ['Repository', 'Service', 'Host', 'HostImage', 'Image']
      if @api_client.config.client_side_validation && opts[:'filter_asset_type'] && !allowable_values.include?(opts[:'filter_asset_type'])
        fail ArgumentError, "invalid value for \"filter_asset_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[token]'] = opts[:'page_token'] if !opts[:'page_token'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'filter[type]'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'filter[cvss.base.score][`$op`]'] = opts[:'filter_cvss_base_score_op'] if !opts[:'filter_cvss_base_score_op'].nil?
      query_params[:'filter[cvss.base.severity]'] = opts[:'filter_cvss_base_severity'] if !opts[:'filter_cvss_base_severity'].nil?
      query_params[:'filter[cvss.base.vector]'] = opts[:'filter_cvss_base_vector'] if !opts[:'filter_cvss_base_vector'].nil?
      query_params[:'filter[cvss.datadog.score][`$op`]'] = opts[:'filter_cvss_datadog_score_op'] if !opts[:'filter_cvss_datadog_score_op'].nil?
      query_params[:'filter[cvss.datadog.severity]'] = opts[:'filter_cvss_datadog_severity'] if !opts[:'filter_cvss_datadog_severity'].nil?
      query_params[:'filter[cvss.datadog.vector]'] = opts[:'filter_cvss_datadog_vector'] if !opts[:'filter_cvss_datadog_vector'].nil?
      query_params[:'filter[status]'] = opts[:'filter_status'] if !opts[:'filter_status'].nil?
      query_params[:'filter[tool]'] = opts[:'filter_tool'] if !opts[:'filter_tool'].nil?
      query_params[:'filter[library.name]'] = opts[:'filter_library_name'] if !opts[:'filter_library_name'].nil?
      query_params[:'filter[library.version]'] = opts[:'filter_library_version'] if !opts[:'filter_library_version'].nil?
      query_params[:'filter[advisory_id]'] = opts[:'filter_advisory_id'] if !opts[:'filter_advisory_id'].nil?
      query_params[:'filter[risks.exploitation_probability]'] = opts[:'filter_risks_exploitation_probability'] if !opts[:'filter_risks_exploitation_probability'].nil?
      query_params[:'filter[risks.poc_exploit_available]'] = opts[:'filter_risks_poc_exploit_available'] if !opts[:'filter_risks_poc_exploit_available'].nil?
      query_params[:'filter[risks.exploit_available]'] = opts[:'filter_risks_exploit_available'] if !opts[:'filter_risks_exploit_available'].nil?
      query_params[:'filter[risks.epss.score][`$op`]'] = opts[:'filter_risks_epss_score_op'] if !opts[:'filter_risks_epss_score_op'].nil?
      query_params[:'filter[risks.epss.severity]'] = opts[:'filter_risks_epss_severity'] if !opts[:'filter_risks_epss_severity'].nil?
      query_params[:'filter[language]'] = opts[:'filter_language'] if !opts[:'filter_language'].nil?
      query_params[:'filter[ecosystem]'] = opts[:'filter_ecosystem'] if !opts[:'filter_ecosystem'].nil?
      query_params[:'filter[code_location.location]'] = opts[:'filter_code_location_location'] if !opts[:'filter_code_location_location'].nil?
      query_params[:'filter[code_location.file_path]'] = opts[:'filter_code_location_file_path'] if !opts[:'filter_code_location_file_path'].nil?
      query_params[:'filter[code_location.method]'] = opts[:'filter_code_location_method'] if !opts[:'filter_code_location_method'].nil?
      query_params[:'filter[fix_available]'] = opts[:'filter_fix_available'] if !opts[:'filter_fix_available'].nil?
      query_params[:'filter[repo_digests]'] = opts[:'filter_repo_digests'] if !opts[:'filter_repo_digests'].nil?
      query_params[:'filter[origin]'] = opts[:'filter_origin'] if !opts[:'filter_origin'].nil?
      query_params[:'filter[asset.name]'] = opts[:'filter_asset_name'] if !opts[:'filter_asset_name'].nil?
      query_params[:'filter[asset.type]'] = opts[:'filter_asset_type'] if !opts[:'filter_asset_type'].nil?
      query_params[:'filter[asset.version.first]'] = opts[:'filter_asset_version_first'] if !opts[:'filter_asset_version_first'].nil?
      query_params[:'filter[asset.version.last]'] = opts[:'filter_asset_version_last'] if !opts[:'filter_asset_version_last'].nil?
      query_params[:'filter[asset.repository_url]'] = opts[:'filter_asset_repository_url'] if !opts[:'filter_asset_repository_url'].nil?
      query_params[:'filter[asset.risks.in_production]'] = opts[:'filter_asset_risks_in_production'] if !opts[:'filter_asset_risks_in_production'].nil?
      query_params[:'filter[asset.risks.under_attack]'] = opts[:'filter_asset_risks_under_attack'] if !opts[:'filter_asset_risks_under_attack'].nil?
      query_params[:'filter[asset.risks.is_publicly_accessible]'] = opts[:'filter_asset_risks_is_publicly_accessible'] if !opts[:'filter_asset_risks_is_publicly_accessible'].nil?
      query_params[:'filter[asset.risks.has_privileged_access]'] = opts[:'filter_asset_risks_has_privileged_access'] if !opts[:'filter_asset_risks_has_privileged_access'].nil?
      query_params[:'filter[asset.risks.has_access_to_sensitive_data]'] = opts[:'filter_asset_risks_has_access_to_sensitive_data'] if !opts[:'filter_asset_risks_has_access_to_sensitive_data'].nil?
      query_params[:'filter[asset.environments]'] = opts[:'filter_asset_environments'] if !opts[:'filter_asset_environments'].nil?
      query_params[:'filter[asset.teams]'] = opts[:'filter_asset_teams'] if !opts[:'filter_asset_teams'].nil?
      query_params[:'filter[asset.arch]'] = opts[:'filter_asset_arch'] if !opts[:'filter_asset_arch'].nil?
      query_params[:'filter[asset.operating_system.name]'] = opts[:'filter_asset_operating_system_name'] if !opts[:'filter_asset_operating_system_name'].nil?
      query_params[:'filter[asset.operating_system.version]'] = opts[:'filter_asset_operating_system_version'] if !opts[:'filter_asset_operating_system_version'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListVulnerabilitiesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :list_vulnerabilities,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_vulnerabilities\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List vulnerable assets.
    #
    # @see #list_vulnerable_assets_with_http_info
    def list_vulnerable_assets(opts = {})
      data, _status_code, _headers = list_vulnerable_assets_with_http_info(opts)
      data
    end

    # List vulnerable assets.
    #
    # Get a list of vulnerable assets.
    #
    # ### Pagination
    #
    # Please review the [Pagination section for the "List Vulnerabilities"](#pagination) endpoint.
    #
    # ### Filtering
    #
    # Please review the [Filtering section for the "List Vulnerabilities"](#filtering) endpoint.
    #
    # ### Metadata
    #
    # Please review the [Metadata section for the "List Vulnerabilities"](#metadata) endpoint.
    #
    #
    # @param opts [Hash] the optional parameters
    # @option opts [String] :page_token Its value must come from the `links` section of the response of the first request. Do not manually edit it.
    # @option opts [Integer] :page_number The page number to be retrieved. It should be equal or greater than `1`
    # @option opts [String] :filter_name Filter by name.
    # @option opts [AssetType] :filter_type Filter by type.
    # @option opts [String] :filter_version_first Filter by the first version of the asset since it has been vulnerable.
    # @option opts [String] :filter_version_last Filter by the last detected version of the asset.
    # @option opts [String] :filter_repository_url Filter by the repository url associated to the asset.
    # @option opts [Boolean] :filter_risks_in_production Filter whether the asset is in production or not.
    # @option opts [Boolean] :filter_risks_under_attack Filter whether the asset (Service) is under attack or not.
    # @option opts [Boolean] :filter_risks_is_publicly_accessible Filter whether the asset (Host) is publicly accessible or not.
    # @option opts [Boolean] :filter_risks_has_privileged_access Filter whether the asset (Host) has privileged access or not.
    # @option opts [Boolean] :filter_risks_has_access_to_sensitive_data Filter whether the asset (Host)  has access to sensitive data or not.
    # @option opts [String] :filter_environments Filter by environment.
    # @option opts [String] :filter_teams Filter by teams.
    # @option opts [String] :filter_arch Filter by architecture.
    # @option opts [String] :filter_operating_system_name Filter by operating system name.
    # @option opts [String] :filter_operating_system_version Filter by operating system version.
    # @return [Array<(ListVulnerableAssetsResponse, Integer, Hash)>] ListVulnerableAssetsResponse data, response status code and response headers
    def list_vulnerable_assets_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.list_vulnerable_assets".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.list_vulnerable_assets")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.list_vulnerable_assets"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.list_vulnerable_assets ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_number'].nil? && opts[:'page_number'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_number"]" when calling SecurityMonitoringAPI.list_vulnerable_assets, must be greater than or equal to 1.'
      end
      allowable_values = ['Repository', 'Service', 'Host', 'HostImage', 'Image']
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !allowable_values.include?(opts[:'filter_type'])
        fail ArgumentError, "invalid value for \"filter_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/v2/security/assets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page[token]'] = opts[:'page_token'] if !opts[:'page_token'].nil?
      query_params[:'page[number]'] = opts[:'page_number'] if !opts[:'page_number'].nil?
      query_params[:'filter[name]'] = opts[:'filter_name'] if !opts[:'filter_name'].nil?
      query_params[:'filter[type]'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'filter[version.first]'] = opts[:'filter_version_first'] if !opts[:'filter_version_first'].nil?
      query_params[:'filter[version.last]'] = opts[:'filter_version_last'] if !opts[:'filter_version_last'].nil?
      query_params[:'filter[repository_url]'] = opts[:'filter_repository_url'] if !opts[:'filter_repository_url'].nil?
      query_params[:'filter[risks.in_production]'] = opts[:'filter_risks_in_production'] if !opts[:'filter_risks_in_production'].nil?
      query_params[:'filter[risks.under_attack]'] = opts[:'filter_risks_under_attack'] if !opts[:'filter_risks_under_attack'].nil?
      query_params[:'filter[risks.is_publicly_accessible]'] = opts[:'filter_risks_is_publicly_accessible'] if !opts[:'filter_risks_is_publicly_accessible'].nil?
      query_params[:'filter[risks.has_privileged_access]'] = opts[:'filter_risks_has_privileged_access'] if !opts[:'filter_risks_has_privileged_access'].nil?
      query_params[:'filter[risks.has_access_to_sensitive_data]'] = opts[:'filter_risks_has_access_to_sensitive_data'] if !opts[:'filter_risks_has_access_to_sensitive_data'].nil?
      query_params[:'filter[environments]'] = opts[:'filter_environments'] if !opts[:'filter_environments'].nil?
      query_params[:'filter[teams]'] = opts[:'filter_teams'] if !opts[:'filter_teams'].nil?
      query_params[:'filter[arch]'] = opts[:'filter_arch'] if !opts[:'filter_arch'].nil?
      query_params[:'filter[operating_system.name]'] = opts[:'filter_operating_system_name'] if !opts[:'filter_operating_system_name'].nil?
      query_params[:'filter[operating_system.version]'] = opts[:'filter_operating_system_version'] if !opts[:'filter_operating_system_version'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListVulnerableAssetsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :list_vulnerable_assets,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#list_vulnerable_assets\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Mute or unmute a batch of findings.
    #
    # @see #mute_findings_with_http_info
    def mute_findings(body, opts = {})
      data, _status_code, _headers = mute_findings_with_http_info(body, opts)
      data
    end

    # Mute or unmute a batch of findings.
    #
    # Mute or unmute findings.
    #
    # @param body [BulkMuteFindingsRequest] ### Attributes  All findings are updated with the same attributes. The request body must include at least two attributes: `muted` and `reason`. The allowed reasons depend on whether the finding is being muted or unmuted:   - To mute a finding: `PENDING_FIX`, `FALSE_POSITIVE`, `ACCEPTED_RISK`, `OTHER`.   - To unmute a finding : `NO_PENDING_FIX`, `HUMAN_ERROR`, `NO_LONGER_ACCEPTED_RISK`, `OTHER`.  ### Meta  The request body must include a list of the finding IDs to be updated. 
    # @param opts [Hash] the optional parameters
    # @return [Array<(BulkMuteFindingsResponse, Integer, Hash)>] BulkMuteFindingsResponse data, response status code and response headers
    def mute_findings_with_http_info(body, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.mute_findings".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.mute_findings")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.mute_findings"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.mute_findings ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.mute_findings"
      end
      # resource path
      local_var_path = '/api/v2/posture_management/findings'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'BulkMuteFindingsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :mute_findings,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#mute_findings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a signal-based notification rule.
    #
    # @see #patch_signal_notification_rule_with_http_info
    def patch_signal_notification_rule(id, body, opts = {})
      data, _status_code, _headers = patch_signal_notification_rule_with_http_info(id, body, opts)
      data
    end

    # Patch a signal-based notification rule.
    #
    # Partially update the notification rule. All fields are optional; if a field is not provided, it is not updated.
    #
    # @param id [String] ID of the notification rule.
    # @param body [PatchNotificationRuleParameters] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def patch_signal_notification_rule_with_http_info(id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.patch_signal_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.patch_signal_notification_rule"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.patch_signal_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/signals/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :patch_signal_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#patch_signal_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a vulnerability-based notification rule.
    #
    # @see #patch_vulnerability_notification_rule_with_http_info
    def patch_vulnerability_notification_rule(id, body, opts = {})
      data, _status_code, _headers = patch_vulnerability_notification_rule_with_http_info(id, body, opts)
      data
    end

    # Patch a vulnerability-based notification rule.
    #
    # Partially update the notification rule. All fields are optional; if a field is not provided, it is not updated.
    #
    # @param id [String] ID of the notification rule.
    # @param body [PatchNotificationRuleParameters] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(NotificationRuleResponse, Integer, Hash)>] NotificationRuleResponse data, response status code and response headers
    def patch_vulnerability_notification_rule_with_http_info(id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.patch_vulnerability_notification_rule ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling SecurityMonitoringAPI.patch_vulnerability_notification_rule"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.patch_vulnerability_notification_rule"
      end
      # resource path
      local_var_path = '/api/v2/security/vulnerabilities/notification_rules/{id}'.sub('{id}', CGI.escape(id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth]

      new_options = opts.merge(
        :operation => :patch_vulnerability_notification_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#patch_vulnerability_notification_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Run a historical job.
    #
    # @see #run_historical_job_with_http_info
    def run_historical_job(body, opts = {})
      data, _status_code, _headers = run_historical_job_with_http_info(body, opts)
      data
    end

    # Run a historical job.
    #
    # Run a historical job.
    #
    # @param body [RunHistoricalJobRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(JobCreateResponse, Integer, Hash)>] JobCreateResponse data, response status code and response headers
    def run_historical_job_with_http_info(body, opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.run_historical_job".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.run_historical_job")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.run_historical_job"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.run_historical_job ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.run_historical_job"
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/jobs'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'JobCreateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :run_historical_job,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#run_historical_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search hist signals.
    #
    # @see #search_security_monitoring_histsignals_with_http_info
    def search_security_monitoring_histsignals(opts = {})
      data, _status_code, _headers = search_security_monitoring_histsignals_with_http_info(opts)
      data
    end

    # Search hist signals.
    #
    # Search hist signals.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [SecurityMonitoringSignalListRequest] :body 
    # @return [Array<(SecurityMonitoringSignalsListResponse, Integer, Hash)>] SecurityMonitoringSignalsListResponse data, response status code and response headers
    def search_security_monitoring_histsignals_with_http_info(opts = {})
      unstable_enabled = @api_client.config.unstable_operations["v2.search_security_monitoring_histsignals".to_sym]
      if unstable_enabled
        @api_client.config.logger.warn format("Using unstable operation '%s'", "v2.search_security_monitoring_histsignals")
      else
        raise DatadogAPIClient::APIError.new(message: format("Unstable operation '%s' is disabled", "v2.search_security_monitoring_histsignals"))
      end

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.search_security_monitoring_histsignals ...'
      end
      # resource path
      local_var_path = '/api/v2/siem-historical-detections/histsignals/search'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :search_security_monitoring_histsignals,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Get, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#search_security_monitoring_histsignals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of security signals.
    #
    # @see #search_security_monitoring_signals_with_http_info
    def search_security_monitoring_signals(opts = {})
      data, _status_code, _headers = search_security_monitoring_signals_with_http_info(opts)
      data
    end

    # Get a list of security signals.
    #
    # Returns security signals that match a search query.
    # Both this endpoint and the GET endpoint can be used interchangeably for listing
    # security signals.
    #
    # @param opts [Hash] the optional parameters
    # @option opts [SecurityMonitoringSignalListRequest] :body 
    # @return [Array<(SecurityMonitoringSignalsListResponse, Integer, Hash)>] SecurityMonitoringSignalsListResponse data, response status code and response headers
    def search_security_monitoring_signals_with_http_info(opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.search_security_monitoring_signals ...'
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/signals/search'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSignalsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :search_security_monitoring_signals,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#search_security_monitoring_signals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of security signals.
    #
    # Provide a paginated version of {#search_security_monitoring_signals}, returning all items.
    #
    # To use it you need to use a block: search_security_monitoring_signals_with_pagination { |item| p item }
    #
    # @yield [SecurityMonitoringSignal] Paginated items
    def search_security_monitoring_signals_with_pagination(opts = {})
        api_version = "V2"
        page_size = @api_client.get_attribute_from_path(opts, "body.page.limit", 10)
        @api_client.set_attribute_from_path(api_version, opts, "body.page.limit", SecurityMonitoringSignalListRequest, page_size)
        while true do
            response = search_security_monitoring_signals(opts)
            @api_client.get_attribute_from_path(response, "data").each { |item| yield(item) }
            if @api_client.get_attribute_from_path(response, "data").length < page_size
              break
            end
            @api_client.set_attribute_from_path(api_version, opts, "body.page.cursor", SecurityMonitoringSignalListRequest, @api_client.get_attribute_from_path(response, "meta.page.after"))
        end
    end

    # Test an existing rule.
    #
    # @see #test_existing_security_monitoring_rule_with_http_info
    def test_existing_security_monitoring_rule(rule_id, body, opts = {})
      data, _status_code, _headers = test_existing_security_monitoring_rule_with_http_info(rule_id, body, opts)
      data
    end

    # Test an existing rule.
    #
    # Test an existing rule.
    #
    # @param rule_id [String] The ID of the rule.
    # @param body [SecurityMonitoringRuleTestRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleTestResponse, Integer, Hash)>] SecurityMonitoringRuleTestResponse data, response status code and response headers
    def test_existing_security_monitoring_rule_with_http_info(rule_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.test_existing_security_monitoring_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.test_existing_security_monitoring_rule"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.test_existing_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}/test'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleTestResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :test_existing_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#test_existing_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Test a rule.
    #
    # @see #test_security_monitoring_rule_with_http_info
    def test_security_monitoring_rule(body, opts = {})
      data, _status_code, _headers = test_security_monitoring_rule_with_http_info(body, opts)
      data
    end

    # Test a rule.
    #
    # Test a rule.
    #
    # @param body [SecurityMonitoringRuleTestRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleTestResponse, Integer, Hash)>] SecurityMonitoringRuleTestResponse data, response status code and response headers
    def test_security_monitoring_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.test_security_monitoring_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.test_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/test'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleTestResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :test_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#test_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a custom framework.
    #
    # @see #update_custom_framework_with_http_info
    def update_custom_framework(handle, version, body, opts = {})
      data, _status_code, _headers = update_custom_framework_with_http_info(handle, version, body, opts)
      data
    end

    # Update a custom framework.
    #
    # Update a custom framework.
    #
    # @param handle [String] The framework handle
    # @param version [String] The framework version
    # @param body [UpdateCustomFrameworkRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(UpdateCustomFrameworkResponse, Integer, Hash)>] UpdateCustomFrameworkResponse data, response status code and response headers
    def update_custom_framework_with_http_info(handle, version, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.update_custom_framework ...'
      end
      # verify the required parameter 'handle' is set
      if @api_client.config.client_side_validation && handle.nil?
        fail ArgumentError, "Missing the required parameter 'handle' when calling SecurityMonitoringAPI.update_custom_framework"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling SecurityMonitoringAPI.update_custom_framework"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.update_custom_framework"
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/custom_frameworks/{handle}/{version}'.sub('{handle}', CGI.escape(handle.to_s).gsub('%2F', '/')).sub('{version}', CGI.escape(version.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'UpdateCustomFrameworkResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_custom_framework,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Put, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#update_custom_framework\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update resource filters.
    #
    # @see #update_resource_evaluation_filters_with_http_info
    def update_resource_evaluation_filters(body, opts = {})
      data, _status_code, _headers = update_resource_evaluation_filters_with_http_info(body, opts)
      data
    end

    # Update resource filters.
    #
    # Update resource filters.
    #
    # @param body [UpdateResourceEvaluationFiltersRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(UpdateResourceEvaluationFiltersResponse, Integer, Hash)>] UpdateResourceEvaluationFiltersResponse data, response status code and response headers
    def update_resource_evaluation_filters_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.update_resource_evaluation_filters ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.update_resource_evaluation_filters"
      end
      # resource path
      local_var_path = '/api/v2/cloud_security_management/resource_filters'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'UpdateResourceEvaluationFiltersResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_resource_evaluation_filters,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Put, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#update_resource_evaluation_filters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a security filter.
    #
    # @see #update_security_filter_with_http_info
    def update_security_filter(security_filter_id, body, opts = {})
      data, _status_code, _headers = update_security_filter_with_http_info(security_filter_id, body, opts)
      data
    end

    # Update a security filter.
    #
    # Update a specific security filter.
    # Returns the security filter object when the request is successful.
    #
    # @param security_filter_id [String] The ID of the security filter.
    # @param body [SecurityFilterUpdateRequest] New definition of the security filter.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityFilterResponse, Integer, Hash)>] SecurityFilterResponse data, response status code and response headers
    def update_security_filter_with_http_info(security_filter_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.update_security_filter ...'
      end
      # verify the required parameter 'security_filter_id' is set
      if @api_client.config.client_side_validation && security_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'security_filter_id' when calling SecurityMonitoringAPI.update_security_filter"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.update_security_filter"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}'.sub('{security_filter_id}', CGI.escape(security_filter_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityFilterResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_security_filter,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#update_security_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an existing rule.
    #
    # @see #update_security_monitoring_rule_with_http_info
    def update_security_monitoring_rule(rule_id, body, opts = {})
      data, _status_code, _headers = update_security_monitoring_rule_with_http_info(rule_id, body, opts)
      data
    end

    # Update an existing rule.
    #
    # Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
    # must be included. For example, when modifying a query all queries must be included.
    # Default rules can only be updated to be enabled, to change notifications, or to update
    # the tags (default tags cannot be removed).
    #
    # @param rule_id [String] The ID of the rule.
    # @param body [SecurityMonitoringRuleUpdatePayload] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringRuleResponse, Integer, Hash)>] SecurityMonitoringRuleResponse data, response status code and response headers
    def update_security_monitoring_rule_with_http_info(rule_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.update_security_monitoring_rule ...'
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling SecurityMonitoringAPI.update_security_monitoring_rule"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.update_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/{rule_id}'.sub('{rule_id}', CGI.escape(rule_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringRuleResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Put, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#update_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a suppression rule.
    #
    # @see #update_security_monitoring_suppression_with_http_info
    def update_security_monitoring_suppression(suppression_id, body, opts = {})
      data, _status_code, _headers = update_security_monitoring_suppression_with_http_info(suppression_id, body, opts)
      data
    end

    # Update a suppression rule.
    #
    # Update a specific suppression rule.
    #
    # @param suppression_id [String] The ID of the suppression rule
    # @param body [SecurityMonitoringSuppressionUpdateRequest] New definition of the suppression rule. Supports partial updates.
    # @param opts [Hash] the optional parameters
    # @return [Array<(SecurityMonitoringSuppressionResponse, Integer, Hash)>] SecurityMonitoringSuppressionResponse data, response status code and response headers
    def update_security_monitoring_suppression_with_http_info(suppression_id, body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.update_security_monitoring_suppression ...'
      end
      # verify the required parameter 'suppression_id' is set
      if @api_client.config.client_side_validation && suppression_id.nil?
        fail ArgumentError, "Missing the required parameter 'suppression_id' when calling SecurityMonitoringAPI.update_security_monitoring_suppression"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.update_security_monitoring_suppression"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/{suppression_id}'.sub('{suppression_id}', CGI.escape(suppression_id.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'SecurityMonitoringSuppressionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :update_security_monitoring_suppression,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Patch, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#update_security_monitoring_suppression\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Validate a detection rule.
    #
    # @see #validate_security_monitoring_rule_with_http_info
    def validate_security_monitoring_rule(body, opts = {})
      validate_security_monitoring_rule_with_http_info(body, opts)
      nil
    end

    # Validate a detection rule.
    #
    # Validate a detection rule.
    #
    # @param body [SecurityMonitoringRuleValidatePayload] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def validate_security_monitoring_rule_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.validate_security_monitoring_rule ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.validate_security_monitoring_rule"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/rules/validation'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :validate_security_monitoring_rule,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#validate_security_monitoring_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Validate a suppression rule.
    #
    # @see #validate_security_monitoring_suppression_with_http_info
    def validate_security_monitoring_suppression(body, opts = {})
      validate_security_monitoring_suppression_with_http_info(body, opts)
      nil
    end

    # Validate a suppression rule.
    #
    # Validate a suppression rule.
    #
    # @param body [SecurityMonitoringSuppressionCreateRequest] 
    # @param opts [Hash] the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def validate_security_monitoring_suppression_with_http_info(body, opts = {})

      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SecurityMonitoringAPI.validate_security_monitoring_suppression ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling SecurityMonitoringAPI.validate_security_monitoring_suppression"
      end
      # resource path
      local_var_path = '/api/v2/security_monitoring/configuration/suppressions/validation'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || [:apiKeyAuth, :appKeyAuth, :AuthZ]

      new_options = opts.merge(
        :operation => :validate_security_monitoring_suppression,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type,
        :api_version => "V2"
      )

      data, status_code, headers = @api_client.call_api(Net::HTTP::Post, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SecurityMonitoringAPI#validate_security_monitoring_suppression\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
